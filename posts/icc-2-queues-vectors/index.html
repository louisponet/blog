<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Inter Core Communication Pt 2: Queues and SeqLock Vectors
        
    </title><meta content="Inter Core Communication Pt 2: Queues and SeqLock Vectors" property=og:title><meta content="Applying the Seqlock in Mantra: Queues and SeqlockVectors" property=og:description><meta content="Applying the Seqlock in Mantra: Queues and SeqlockVectors" name=description><link href=/icon/favicon.svg rel=icon type=image/png><link href=https://louisponet.github.io/blog/fonts.css rel=stylesheet><script src=https://louisponet.github.io/blog/js/codeblock.js></script><script src=https://louisponet.github.io/blog/js/toc.js></script><script>MathJax={tex:{inlineMath:[[`\$`,`\$`],[`\\\\(`,`\\\\)`]]}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Louis Ponet" href=https://louisponet.github.io/blog/atom.xml rel=alternate type=application/atom+xml><link href=https://louisponet.github.io/blog/theme/light.css rel=stylesheet><link href=https://louisponet.github.io/blog/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://louisponet.github.io/blog/js/themetoggle.js></script><script>setTheme(getSavedTheme())</script><link href=https://louisponet.github.io/blog/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://louisponet.github.io/blog>Louis Ponet</a><div class=socials><a class=social href=https://github.com/louisponet/ rel=me> <img alt=github src=https://louisponet.github.io/blog/social_icons/github.svg> </a><a class=social href=https://www.linkedin.com/in/louis-ponet-phd-384ba0b6/ rel=me> <img alt=linkedin src=https://louisponet.github.io/blog/social_icons/linkedin.svg> </a><a href="https://scholar.google.com/citations?hl=en&user=oAp2Siow_v8C" class=social rel=me> <img alt=scholar src=https://louisponet.github.io/blog/social_icons/scholar.svg> </a><a href="mailto:louisponet@gmail.com?subject=Howdy%20from%20your%20blog" class=social rel=me> <img alt=email src=https://louisponet.github.io/blog/social_icons/email.svg> </a></div></div><nav><a href=https://louisponet.github.io/blog/posts style=margin-left:.5em>/posts</a><a href=https://louisponet.github.io/blog/about style=margin-left:.5em>/about</a><a href=https://louisponet.github.io/blog/tags style=margin-left:.5em>/tags</a> |<a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://louisponet.github.io/blog/feather/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://louisponet.github.io/blog/feather/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>Inter Core Communication Pt 2: Queues and SeqLock Vectors<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2024-07-14</time><span class=tags-label> :: Tags:</span><span class=tags> <a class=post-tag href=https://louisponet.github.io/blog/tags/mantra/>mantra</a>, <a class=post-tag href=https://louisponet.github.io/blog/tags/icc/>icc</a>, <a class=post-tag href=https://louisponet.github.io/blog/tags/seqlock/>seqlock</a>, <a class=post-tag href=https://louisponet.github.io/blog/tags/mpmc/>mpmc</a>, <a class=post-tag href=https://louisponet.github.io/blog/tags/queue/>queue</a> </span></div></div><div class=toc-container><h1 class=toc-title>Table of Contents</h1><ul class=toc-list><li><a href=https://louisponet.github.io/blog/posts/icc-2-queues-vectors/#seqlockvector>SeqlockVector</a> <ul><li><a href=https://louisponet.github.io/blog/posts/icc-2-queues-vectors/#seqlockvectorheader>SeqlockVectorHeader</a><li><a href=https://louisponet.github.io/blog/posts/icc-2-queues-vectors/#initialization>Initialization</a><li><a href=https://louisponet.github.io/blog/posts/icc-2-queues-vectors/#read-write>Read/write</a></ul><li><a href=https://louisponet.github.io/blog/posts/icc-2-queues-vectors/#spmc-mpmc-message-queues>SPMC/MPMC Message Queues</a> <ul><li><a href=https://louisponet.github.io/blog/posts/icc-2-queues-vectors/#producer>Producer</a><li><a href=https://louisponet.github.io/blog/posts/icc-2-queues-vectors/#consumer-implementation>Consumer implementation</a></ul><li><a href=https://louisponet.github.io/blog/posts/icc-2-queues-vectors/#conclusion>Conclusion</a></ul></div><section class=body><p>Welcome back to the second of a series of posts detailing the inter core communication components used in <a href=https://louisponet.github.io/blog/posts/hello-world/><strong>Mantra</strong></a>.<p>In the previous post I detailed the implementation and functionality of the <code>Seqlock</code>. As mentioned then, it is the core building block for all inter core synchronization in <strong>Mantra</strong>. In this second post, we will use it to construct the low-latency message <code>Queues</code> for event based communication, and <code>SeqlockVectors</code> for communicating the "latest" information. One example of the latter are the "ideal positions" that algo models produce based on incoming market data.<p>The <code>SeqlockVectors</code> are certainly the most straightforward of the two datastructures, so let's start with those.<h1 id=seqlockvector><a aria-label="Anchor link for: seqlockvector" class=zola-anchor href=#seqlockvector>SeqlockVector</a></h1><p>As the name suggests, a <code>SeqlockVector</code> is really not much more than a contiguous buffer of <code>Seqlocks</code>. Each <code>[Version, Data, Padding]</code> triple in the image below denotes one <code>Seqlock</code>:<p><img alt src=https://louisponet.github.io/blog/posts/icc-2-queues-vectors/SeqlockVector.svg#noborder title=SeqlockVector> <em>Fig 1. SeqlockVector</em><p>Our implementation allows constructing them in the private memory of a given process as well as in a piece of shared memory created by the OS.<h2 id=seqlockvectorheader><a aria-label="Anchor link for: seqlockvectorheader" class=zola-anchor href=#seqlockvectorheader>SeqlockVectorHeader</a></h2><p>To maximize the <code>SeqlockVector's</code> flexibility we also want it to describe itself to some degree by using the following <code>SeqlockVectorHeader</code> structure (shown in blue in the above figure):<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>derive</span><span>(Debug)]
</span><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>repr</span><span>(C)]
</span><span style=color:#f73>pub struct </span><span style=color:#59c2ff>SeqlockVectorHeader </span><span>{
</span><span>    elsize</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>usize</span><span>,
</span><span>    bufsize</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>usize
</span><span>}
</span></code></pre><p>A bit underwhelming, perhaps. Nonetheless, it contains the information needed to allow a process to read the <code>SeqlockHeader</code> from shared memory, and know the number of bytes comprising each element (<code>elsize</code>), the number of elements (<code>bufsize</code>), and thus the total bytesize of the <code>SeqlockVector</code>:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#f73>const fn </span><span style=color:#ffb454>size_of</span><span>(</span><span style=color:#f29718>bufsize</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>usize</span><span>) </span><span style=color:#bfbab0cc>-> </span><span style=color:#f73>usize </span><span>{
</span><span>    std</span><span style=color:#f29668>::</span><span>mem</span><span style=color:#f29668>::</span><span>size_of</span><span style=color:#f29668>::</span><span>&LTSeqlockVectorHeader>()
</span><span>        </span><span style=color:#f29668>+</span><span> bufsize </span><span style=color:#f29668>* </span><span>std</span><span style=color:#f29668>::</span><span>mem</span><span style=color:#f29668>::</span><span>size_of</span><span style=color:#f29668>::</span><span>&LTSeqlock&LTT>>()
</span><span>}
</span></code></pre><p>We use <code>[repr(C)]</code> to stop the compiler from reordering the struct fields. This is mainly useful when accessing the <code>SeqlockVector</code> in shared memory by programs implemented in programming languages other than rust.<blockquote><p>Theoretically fields can also be ordered differently by rust compilers with different versions.</blockquote><h2 id=initialization><a aria-label="Anchor link for: initialization" class=zola-anchor href=#initialization>Initialization</a></h2><p>The <code>SeqlockVector</code> and its initialization are implemented as follows:<pre class=language-rust data-lang=rust data-linenos style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><table><tbody><tr><td>1<td><span style=color:#f73>use </span><span>std</span><span style=color:#f29668>::</span><span>mem</span><span style=color:#f29668>::</span><span>{size_of</span><span style=color:#bfbab0cc>,</span><span> forget}</span><span style=color:#bfbab0cc>;
</span><tr><td>2<td><span style=color:#f73>use </span><span>std</span><span style=color:#f29668>::</span><span>ptr</span><span style=color:#f29668>::</span><span>slice_from_raw_parts_mut</span><span style=color:#bfbab0cc>;
</span><tr><td>3<td><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>repr</span><span>(C)]
</span><tr><td>4<td><span style=color:#f73>pub struct </span><span style=color:#59c2ff>SeqlockVector</span><span>&LTT</span><span style=color:#bfbab0cc>: </span><span style=color:#39bae6;font-style:italic>Copy</span><span>> {
</span><tr><td>5<td><span>    header</span><span style=color:#bfbab0cc>:</span><span> VectorHeader,
</span><tr><td>6<td><span>    buffer</span><span style=color:#bfbab0cc>:</span><span> [Seqlock&LTT>],
</span><tr><td>7<td><span>}
</span><tr><td>8<td><span style=color:#f73>impl</span><span>&LTT</span><span style=color:#bfbab0cc>: </span><span style=color:#39bae6;font-style:italic>Copy</span><span>> </span><span style=color:#59c2ff>SeqlockVector</span><span>&LTT> {
</span><tr><td>9<td><span>    </span><span style=color:#f73>const fn </span><span style=color:#ffb454>size_of</span><span>(</span><span style=color:#f29718>bufsize</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>usize</span><span>) </span><span style=color:#bfbab0cc>-> </span><span style=color:#f73>usize </span><span>{
</span><tr><td>10<td><span>        size_of</span><span style=color:#f29668>::</span><span>&LTSeqlockVectorHeader>()
</span><tr><td>11<td><span>            </span><span style=color:#f29668>+</span><span> bufsize </span><span style=color:#f29668>* </span><span>size_of</span><span style=color:#f29668>::</span><span>&LTSeqlock&LTT>>()
</span><tr><td>12<td><span>    }
</span><tr><td>13<td><span>
</span><tr><td>14<td><span>    </span><span style=color:#f73>pub fn </span><span style=color:#ffb454>private</span><span>(</span><span style=color:#f29718>bufsize</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>usize</span><span>) </span><span style=color:#bfbab0cc>-> </span><span style=color:#f29668>&</span><span style=color:#f73>'static Self </span><span>{
</span><tr><td>15<td><span>        </span><span style=color:#f73>let</span><span> size </span><span style=color:#f29668>= </span><span style=color:#f73>Self</span><span style=color:#f29668>::</span><span>size_of(bufsize)</span><span style=color:#bfbab0cc>;
</span><tr><td>16<td><span>        </span><span style=color:#f73>unsafe </span><span>{
</span><tr><td>17<td><span>            </span><span style=color:#f73>let</span><span> ptr </span><span style=color:#f29668>= </span><span>std</span><span style=color:#f29668>::</span><span>alloc</span><span style=color:#f29668>::</span><span>alloc_zeroed(
</span><tr><td>18<td><span>                Layout</span><span style=color:#f29668>::</span><span>array</span><span style=color:#f29668>::</span><span><</span><span style=color:#f73>u8</span><span>>(size)
</span><tr><td>19<td><span>                    </span><span style=color:#f29668>.</span><span style=color:#f07178>unwrap</span><span>()
</span><tr><td>20<td><span>                    </span><span style=color:#f29668>.</span><span style=color:#f07178>align_to</span><span>(</span><span style=color:#f29718>64</span><span>)
</span><tr><td>21<td><span>                    </span><span style=color:#f29668>.</span><span style=color:#f07178>unwrap</span><span>()
</span><tr><td>22<td><span>                    </span><span style=color:#f29668>.</span><span style=color:#f07178>pad_to_align</span><span>()</span><span style=color:#bfbab0cc>,
</span><tr><td>23<td><span>            )</span><span style=color:#bfbab0cc>;
</span><tr><td>24<td><span>            </span><span style=color:#f73>Self</span><span style=color:#f29668>::</span><span>from_uninitialized_ptr(ptr</span><span style=color:#bfbab0cc>,</span><span> bufsize)
</span><tr><td>25<td><span>        }
</span><tr><td>26<td><span>    }
</span><tr><td>27<td><span>
</span><tr><td>28<td><span>    </span><span style=color:#f73>pub fn </span><span style=color:#ffb454>shared</span><span>&LTP</span><span style=color:#bfbab0cc>: </span><span style=color:#39bae6;font-style:italic>AsRef</span><span>&LTstd</span><span style=color:#f29668>::</span><span>path</span><span style=color:#f29668>::</span><span>Path>>(
</span><tr><td>29<td><span>        </span><span style=color:#f29718>shmem_flink</span><span style=color:#bfbab0cc>:</span><span> P,
</span><tr><td>30<td><span>        </span><span style=color:#f29718>bufsize</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>usize</span><span>,
</span><tr><td>31<td><span>    ) </span><span style=color:#bfbab0cc>-> </span><span style=color:#39bae6;font-style:italic>Result</span><span><</span><span style=color:#f29668>&</span><span style=color:#f73>'static Self</span><span>, </span><span style=color:#f29668>&</span><span style=color:#f73>'static str</span><span>> {
</span><tr><td>32<td><span>        </span><span style=color:#f73>use </span><span>shared_memory</span><span style=color:#f29668>::</span><span>{ShmemConf</span><span style=color:#bfbab0cc>,</span><span> ShmemError}</span><span style=color:#bfbab0cc>;
</span><tr><td>33<td><span>        </span><span style=color:#f73>match </span><span>ShmemConf</span><span style=color:#f29668>::</span><span>new()
</span><tr><td>34<td><span>            </span><span style=color:#f29668>.</span><span style=color:#f07178>size</span><span>(</span><span style=color:#f73>Self</span><span style=color:#f29668>::</span><span>size_of(bufsize))
</span><tr><td>35<td><span>            </span><span style=color:#f29668>.</span><span style=color:#f07178>flink</span><span>(</span><span style=color:#f29668>&</span><span>shmem_flink)
</span><tr><td>36<td><span>            </span><span style=color:#f29668>.</span><span style=color:#f07178>create</span><span>()
</span><tr><td>37<td><span>        {
</span><tr><td>38<td><span>            </span><span style=color:#39bae6;font-style:italic>Ok</span><span>(shmem) </span><span style=color:#f29668>=> </span><span>{
</span><tr><td>39<td><span>                </span><span style=color:#f73>let</span><span> ptr </span><span style=color:#f29668>=</span><span> shmem</span><span style=color:#f29668>.</span><span style=color:#f07178>as_ptr</span><span>()</span><span style=color:#bfbab0cc>;
</span><tr><td><mark style=background-color:#0a0e12>40</mark><td><mark style=background-color:#0a0e12><span>                </span><span style=color:#f07178>forget</span><span>(shmem)</span><span style=color:#bfbab0cc>;
</span></mark><tr><td>41<td><span>                </span><span style=color:#39bae6;font-style:italic>Ok</span><span>(</span><span style=color:#f73>Self</span><span style=color:#f29668>::</span><span>from_uninitialized_ptr(ptr</span><span style=color:#bfbab0cc>,</span><span> bufsize))
</span><tr><td>42<td><span>            }
</span><tr><td>43<td><span>            </span><span style=color:#39bae6;font-style:italic>Err</span><span>(ShmemError</span><span style=color:#f29668>::</span><span>LinkExists) </span><span style=color:#f29668>=> </span><span>{
</span><tr><td>44<td><span>                </span><span style=color:#f73>let</span><span> shmem </span><span style=color:#f29668>= </span><span>ShmemConf</span><span style=color:#f29668>::</span><span>new()</span><span style=color:#f29668>.</span><span style=color:#f07178>flink</span><span>(shmem_flink)</span><span style=color:#f29668>.</span><span style=color:#f07178>open</span><span>()</span><span style=color:#f29668>.</span><span style=color:#f07178>unwrap</span><span>()</span><span style=color:#bfbab0cc>;
</span><tr><td>45<td><span>                </span><span style=color:#f73>let</span><span> ptr </span><span style=color:#f29668>=</span><span> shmem</span><span style=color:#f29668>.</span><span style=color:#f07178>as_ptr</span><span>() </span><span style=color:#f29668>as </span><span style=color:#f73>*mut</span><span> VectorHeader</span><span style=color:#bfbab0cc>;
</span><tr><td>46<td><span>
</span><tr><td>47<td><span>
</span><tr><td>48<td><span>                </span><span style=color:#f73>let</span><span> v </span><span style=color:#f29668>= </span><span style=color:#f73>Self</span><span style=color:#f29668>::</span><span>from_initialized_ptr(ptr)</span><span style=color:#bfbab0cc>;
</span><tr><td>49<td><span>                </span><span style=color:#f73>if</span><span> v</span><span style=color:#f29668>.</span><span>header</span><span style=color:#f29668>.</span><span>bufsize </span><span style=color:#f29668><</span><span> bufsize {
</span><tr><td>50<td><span>                    </span><span style=color:#39bae6;font-style:italic>Err</span><span>(</span><span style=color:#c2d94c>"Existing shmem too small"</span><span>)
</span><tr><td>51<td><span>                } </span><span style=color:#f73>else </span><span>{
</span><tr><td>52<td><span>                    v</span><span style=color:#f29668>.</span><span>header</span><span style=color:#f29668>.</span><span>bufsize </span><span style=color:#f29668>=</span><span> bufsize</span><span style=color:#bfbab0cc>;
</span><tr><td><mark style=background-color:#0a0e12>53</mark><td><mark style=background-color:#0a0e12><span>                    </span><span style=color:#f07178>forget</span><span>(shmem)</span><span style=color:#bfbab0cc>; </span><span style=color:#5c6773;font-style:italic>// shared_memory will be cleaned up when `Dropping`, so we explicitely leak it here.
</span></mark><tr><td>54<td><span>                    </span><span style=color:#39bae6;font-style:italic>Ok</span><span>(v)
</span><tr><td>55<td><span>                }
</span><tr><td>56<td><span>            }
</span><tr><td>57<td><span>            </span><span style=color:#39bae6;font-style:italic>Err</span><span>(</span><span style=color:#f29668>_</span><span>) </span><span style=color:#f29668>=> </span><span>{
</span><tr><td>58<td><span>                </span><span style=color:#39bae6;font-style:italic>Err</span><span>(</span><span style=color:#c2d94c>"Unable to create or open shmem flink."</span><span>)
</span><tr><td>59<td><span>            }
</span><tr><td>60<td><span>        }
</span><tr><td>61<td><span>    }
</span><tr><td>62<td><span>
</span><tr><td>63<td><span>    </span><span style=color:#f73>pub fn </span><span style=color:#ffb454>from_uninitialized_ptr</span><span>(
</span><tr><td>64<td><span>        </span><span style=color:#f29718>ptr</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>*mut u8</span><span>,
</span><tr><td>65<td><span>        </span><span style=color:#f29718>bufsize</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>usize</span><span>,
</span><tr><td>66<td><span>    ) </span><span style=color:#bfbab0cc>-> </span><span style=color:#f29668>&</span><span style=color:#f73>'static Self </span><span>{
</span><tr><td>67<td><span>        </span><span style=color:#f73>unsafe </span><span>{
</span><tr><td><mark style=background-color:#0a0e12>68</mark><td><mark style=background-color:#0a0e12><span>            </span><span style=color:#f73>let</span><span> q </span><span style=color:#f29668>= &*</span><span>(</span><span style=color:#f07178>slice_from_raw_parts_mut</span><span>(ptr</span><span style=color:#bfbab0cc>,</span><span> bufsize) </span><span style=color:#f29668>as </span><span style=color:#f73>*const </span><span>SeqlockVector&LTT>)</span><span style=color:#bfbab0cc>;
</span></mark><tr><td>69<td><span>            </span><span style=color:#f73>let</span><span> elsize </span><span style=color:#f29668>= </span><span>size_of</span><span style=color:#f29668>::</span><span>&LTSeqLock&LTT>>()</span><span style=color:#bfbab0cc>;
</span><tr><td>70<td><span>            q</span><span style=color:#f29668>.</span><span>header</span><span style=color:#f29668>.</span><span>bufsize </span><span style=color:#f29668>=</span><span> bufsize</span><span style=color:#bfbab0cc>;
</span><tr><td>71<td><span>            q</span><span style=color:#f29668>.</span><span>header</span><span style=color:#f29668>.</span><span>elsize </span><span style=color:#f29668>=</span><span> elsize</span><span style=color:#bfbab0cc>;
</span><tr><td>72<td><span>            q
</span><tr><td>73<td><span>        }
</span><tr><td>74<td><span>    }
</span><tr><td>75<td><span>
</span><tr><td>76<td><span>    </span><span style=color:#f73>fn </span><span style=color:#ffb454>from_initialized_ptr</span><span>(</span><span style=color:#f29718>ptr</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>*mut</span><span> VectorHeader) </span><span style=color:#bfbab0cc>-> </span><span style=color:#f29668>&</span><span style=color:#f73>'static Self </span><span>{
</span><tr><td>77<td><span>        </span><span style=color:#f73>unsafe </span><span>{
</span><tr><td>78<td><span>            </span><span style=color:#f73>let</span><span> bufsize </span><span style=color:#f29668>= </span><span>(</span><span style=color:#f29668>*</span><span>ptr)</span><span style=color:#f29668>.</span><span>bufsize</span><span style=color:#bfbab0cc>;
</span><tr><td><mark style=background-color:#0a0e12>79</mark><td><mark style=background-color:#0a0e12><span>            </span><span style=color:#f29668>&*</span><span>(</span><span style=color:#f07178>slice_from_raw_parts_mut</span><span>(ptr</span><span style=color:#bfbab0cc>,</span><span> bufsize) </span><span style=color:#f29668>as </span><span style=color:#f73>*const </span><span>SeqlockVector&LTT>)
</span></mark><tr><td>80<td><span>        }
</span><tr><td>81<td><span>    }
</span><tr><td>82<td><span>
</span><tr><td>83<td><span>    </span><span style=color:#f73>pub fn </span><span style=color:#ffb454>len</span><span>(</span><span style=color:#f29668>&</span><span style=color:#f29718>self</span><span>) </span><span style=color:#bfbab0cc>-> </span><span style=color:#f73>usize </span><span>{
</span><tr><td>84<td><span>        </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>header</span><span style=color:#f29668>.</span><span>bufsize
</span><tr><td>85<td><span>    }
</span><tr><td>86<td><span>}
</span></table></code></pre><p>The total size of a <code>SeqlockVector&LTT></code> is given by the <code>size_of</code> function, <code>private</code> creates a new <code>SeqlockVector</code> in private memory only, and <code>shared</code> creates or opens a <code>SeqlockVector</code> in shared memory. For the latter functionality we use the <a href=https://docs.rs/shared_memory/latest/shared_memory/><code>shared_memory</code></a> crate.<p>I have highlighted the notably tricky parts of the code. The first two make sure that opened shared memory does not get automatically cleaned up when <code>shmem</code> gets dropped by using <code>forget</code>, while the last two create a reference to the <code>SeqlockedVector</code> from the raw shared memory pointer.<div class=note-container><div class=note-header><div class=note-icon><p>Note!</div></div><div class=note-content><p>Even though <code>slice_from_raw_parts_mut</code> is used to create a reference to the whole <code>SeqlockVector</code>, the <code>length</code> argument denotes the length of the unsized <code>buffer</code> slice only!</div></div><h2 id=read-write><a aria-label="Anchor link for: read-write" class=zola-anchor href=#read-write>Read/write</a></h2><p>The <code>read</code> and <code>write</code> implementations of the <code>SeqlockVector</code> are straightforwardly based on those of the <a href=https://louisponet.github.io/blog/posts/icc-1-seqlock/#tl-dr><code>Seqlock</code></a>. See the code <a href=https://github.com/louisponet/blog/blob/cd94640d5b372ae7cccfcae3bd366929284897a2/content/posts/icc_2_queues_vectors/code/src/vector.rs#L64-L106>here</a>.<h1 id=spmc-mpmc-message-queues><a aria-label="Anchor link for: spmc-mpmc-message-queues" class=zola-anchor href=#spmc-mpmc-message-queues>SPMC/MPMC Message Queues</a></h1><p>Without skippin a beat, we continue with the second datastructure that plays an even bigger role in <strong>Mantra</strong>. Low-latency single/multi producer multi consumer message <code>Queues</code> form the basis for the modular and robust architecture of <strong>Mantra</strong>.<p>The underlying structure is pretty much identical to the <code>SeqlockVector</code>, i.e. a <code>buffer</code> of <code>Seqlocks</code> with the actual data, and a <code>QueueHeader</code> with metadata about the <code>Queue</code>. As will become clear in due course, the <code>buffer</code> in this case is used as a ringbuffer.<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>repr</span><span>(u8)]
</span><span style=color:#f73>pub enum </span><span style=color:#59c2ff>QueueType </span><span>{
</span><span>    Unknown</span><span style=color:#bfbab0cc>,
</span><span>    </span><span style=color:#f29718>MPMC</span><span style=color:#bfbab0cc>,
</span><span>    </span><span style=color:#f29718>SPMC</span><span style=color:#bfbab0cc>,
</span><span>}
</span><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>repr</span><span>(C)]
</span><span style=color:#f73>pub struct </span><span style=color:#59c2ff>QueueHeader </span><span>{
</span><span>    </span><span style=color:#f73>pub </span><span>queue_type</span><span style=color:#bfbab0cc>:</span><span>         QueueType,   </span><span style=color:#5c6773;font-style:italic>// 1
</span><span>    </span><span style=color:#f73>pub </span><span>is_initialized</span><span style=color:#bfbab0cc>:     </span><span style=color:#f73>u8</span><span>,          </span><span style=color:#5c6773;font-style:italic>// 2
</span><span>    _pad1</span><span style=color:#bfbab0cc>:</span><span>                  [</span><span style=color:#f73>u8</span><span>; 6]      </span><span style=color:#5c6773;font-style:italic>// 8
</span><span>    pub elsize</span><span style=color:#bfbab0cc>:             </span><span style=color:#f73>usize</span><span>,       </span><span style=color:#5c6773;font-style:italic>// 16
</span><span>    mask</span><span style=color:#bfbab0cc>:                   </span><span style=color:#f73>usize</span><span>,       </span><span style=color:#5c6773;font-style:italic>// 24
</span><span>    </span><span style=color:#f73>pub </span><span>count</span><span style=color:#bfbab0cc>:</span><span>              AtomicUsize, </span><span style=color:#5c6773;font-style:italic>// 32
</span><span>}
</span><span>
</span><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>repr</span><span>(C)]
</span><span style=color:#f73>pub struct </span><span style=color:#59c2ff>Queue</span><span>&LTT> {
</span><span>    </span><span style=color:#f73>pub </span><span>header</span><span style=color:#bfbab0cc>:</span><span> QueueHeader,
</span><span>    buffer</span><span style=color:#bfbab0cc>:</span><span>     [seqlock</span><span style=color:#f29668>::</span><span>SeqLock&LTT>],
</span><span>}
</span></code></pre><p>Before continuing with the <code>Producer</code> and <code>Consumer</code> implementations, let me <a href=https://louisponet.github.io/blog/posts/hello-world/#queue>reiterate</a> that <code>Producers</code> are oblivious to the attached <code>Consumers</code>, leading to a couple clear benefits:<ul><li>improves performance through less shared data and thus inter-core communication<li>greatly simplifying the implementation<li>a single misbehaving <code>Consumer</code> does not halt the entire system<li>attaching more <code>Consumers</code> to a <code>Queue</code> is trivial as it does not impacting the performance or functionality of the rest of the system</ul><p>One obvious negative is that <code>Consumers</code> can get sped past by <code>Producers</code>, leading to data loss from dropped messages.<p>Luckily, this happens extremely infrequently in reality and all observed cases were easily remedied by optimizing the code or offloading to another <code>Consumer</code> on an additional cores. The points outlined above mean that even the latter, more dramatic case, is easily implementable.<p>Nonetheless, we at least want <code>Consumers</code> to be able to autonomously detect when they are sped past. As we will demonstrate, this can be achieved even though the only shared data between <code>Consumers</code> and <code>Producers</code> is the <code>buffer</code> of <code>Seqlocks</code>.<p>One final remark before continuing with the implemenation details is that all <code>Consumers</code> observe all messages flowing through a given <code>Queue</code>. This is sometimes referred to as <code>broadcast</code> or <code>multicast</code> mode.<h2 id=producer><a aria-label="Anchor link for: producer" class=zola-anchor href=#producer><code>Producer</code></a></h2><pre class=language-rust data-lang=rust data-linenos style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><table><tbody><tr><td>1<td><span style=color:#f73>impl</span><span>&LTT</span><span style=color:#bfbab0cc>: </span><span style=color:#39bae6;font-style:italic>Copy</span><span>> </span><span style=color:#59c2ff>Queue</span><span>&LTT> {
</span><tr><td>2<td><span>
</span><tr><td>3<td><span>    </span><span style=color:#f73>pub fn </span><span style=color:#ffb454>len</span><span>(</span><span style=color:#f29668>&</span><span style=color:#f29718>self</span><span>) </span><span style=color:#bfbab0cc>-> </span><span style=color:#f73>usize </span><span>{
</span><tr><td>4<td><span>        </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>header</span><span style=color:#f29668>.</span><span>mask </span><span style=color:#f29668>+ </span><span style=color:#f29718>1
</span><tr><td>5<td><span>    }
</span><tr><td>6<td><span>
</span><tr><td>7<td><span>    </span><span style=color:#f73>fn </span><span style=color:#ffb454>next_count</span><span>(</span><span style=color:#f29668>&</span><span style=color:#f29718>self</span><span>) </span><span style=color:#bfbab0cc>-> </span><span style=color:#f73>usize </span><span>{
</span><tr><td>8<td><span>        </span><span style=color:#f73>match </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>header</span><span style=color:#f29668>.</span><span>queue_type {
</span><tr><td>9<td><span>            QueueType</span><span style=color:#f29668>::</span><span>Unknown </span><span style=color:#f29668>=> </span><span style=color:#f07178>panic!</span><span>(</span><span style=color:#c2d94c>"Unknown queue"</span><span>)</span><span style=color:#bfbab0cc>,
</span><tr><td>10<td><span>            QueueType</span><span style=color:#f29668>::</span><span style=color:#f29718>MPMC </span><span style=color:#f29668>=> </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>header</span><span style=color:#f29668>.</span><span>count</span><span style=color:#f29668>.</span><span style=color:#f07178>fetch_add</span><span>(</span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>, </span><span>Ordering</span><span style=color:#f29668>::</span><span>AcqRel)</span><span style=color:#bfbab0cc>,
</span><tr><td>11<td><span>            QueueType</span><span style=color:#f29668>::</span><span style=color:#f29718>SPMC </span><span style=color:#f29668>=> </span><span>{
</span><tr><td>12<td><span>                </span><span style=color:#f73>let</span><span> c </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>header</span><span style=color:#f29668>.</span><span>count</span><span style=color:#f29668>.</span><span style=color:#f07178>load</span><span>(Ordering</span><span style=color:#f29668>::</span><span>Relaxed)</span><span style=color:#bfbab0cc>;
</span><tr><td>13<td><span>                </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>header
</span><tr><td>14<td><span>                    </span><span style=color:#f29668>.</span><span>count
</span><tr><td>15<td><span>                    </span><span style=color:#f29668>.</span><span style=color:#f07178>store</span><span>(c</span><span style=color:#f29668>.</span><span style=color:#f07178>wrapping_add</span><span>(</span><span style=color:#f29718>1</span><span>)</span><span style=color:#bfbab0cc>, </span><span>Ordering</span><span style=color:#f29668>::</span><span>Relaxed)</span><span style=color:#bfbab0cc>;
</span><tr><td>16<td><span>                c
</span><tr><td>17<td><span>            }
</span><tr><td>18<td><span>        }
</span><tr><td>19<td><span>    }
</span><tr><td>20<td><span>    </span><span style=color:#f73>fn </span><span style=color:#ffb454>load</span><span>(</span><span style=color:#f29668>&</span><span style=color:#f29718>self</span><span>, </span><span style=color:#f29718>pos</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>usize</span><span>) </span><span style=color:#bfbab0cc>-> </span><span style=color:#f29668>&</span><span>SeqLock&LTT> {
</span><tr><td>21<td><span>        </span><span style=color:#f73>unsafe </span><span>{ </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>buffer</span><span style=color:#f29668>.</span><span style=color:#f07178>get_unchecked</span><span>(pos) }
</span><tr><td>22<td><span>    }
</span><tr><td>23<td><span>
</span><tr><td>24<td><span>    </span><span style=color:#f73>fn </span><span style=color:#ffb454>produce</span><span>(</span><span style=color:#f29668>&</span><span style=color:#f29718>self</span><span>, </span><span style=color:#f29718>item</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>T) </span><span style=color:#bfbab0cc>-> </span><span style=color:#f73>usize </span><span>{
</span><tr><td>25<td><span>        </span><span style=color:#f73>let</span><span> p </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span style=color:#f07178>next_count</span><span>()</span><span style=color:#bfbab0cc>;
</span><tr><td><mark style=background-color:#0a0e12>26</mark><td><mark style=background-color:#0a0e12><span>        </span><span style=color:#f73>let</span><span> lock </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span style=color:#f07178>load</span><span>(p </span><span style=color:#f29668>& </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>header</span><span style=color:#f29668>.</span><span>mask)</span><span style=color:#bfbab0cc>;
</span></mark><tr><td>27<td><span>        lock</span><span style=color:#f29668>.</span><span style=color:#f07178>write</span><span>(item)</span><span style=color:#bfbab0cc>;
</span><tr><td>28<td><span>        p
</span><tr><td>29<td><span>    }
</span><tr><td>30<td><span>
</span><tr><td>31<td><span>}
</span></table></code></pre><p>The <code>count</code> field is used to keep track of the position of the next free slot to write a message into.<p>The <code>mask</code> is used to make sure that the <code>Producer</code> loops back to the start of the <code>Queue</code> when it reaches the end of the <code>buffer</code>: if we only allow <code>Queue</code> sizes that are a power of two and set <code>mask</code> equal to <code>busize - 1</code>, the <code>p & self.header.mask</code> in line 21 is the same as <code>p % bufsize</code>. Let's try to understand this with a minimal example:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#f73>let</span><span> bufsize </span><span style=color:#f29668>= </span><span style=color:#f29718>8</span><span style=color:#bfbab0cc>;
</span><span style=color:#f73>let</span><span> mask </span><span style=color:#f29668>= </span><span style=color:#f29718>8 </span><span style=color:#f29668>- </span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>;            </span><span style=color:#5c6773;font-style:italic>// 7
</span><span style=color:#f73>let</span><span> p </span><span style=color:#f29668>= </span><span style=color:#f29718>7 </span><span style=color:#f29668>&</span><span> mask</span><span style=color:#bfbab0cc>;            </span><span style=color:#5c6773;font-style:italic>// 0x...0111 & 0x...0111 = 0x...0111 = 7
</span><span style=color:#f73>let</span><span> p_next </span><span style=color:#f29668>= </span><span>(p </span><span style=color:#f29668>+ </span><span style=color:#f29718>1</span><span>) </span><span style=color:#f29668>&</span><span> mask</span><span style=color:#bfbab0cc>; </span><span style=color:#5c6773;font-style:italic>// 0x...1000 & 0x...0111 = 0x...0000 = 0
</span></code></pre><p>Very clever. Unfortunately I can not claim authorship of this rather well known trick, alas. It also avoids using<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#f73>if </span><span>(</span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>header</span><span style=color:#f29668>.</span><span>count </span><span style=color:#f29668>== </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span style=color:#f07178>len</span><span>()) {
</span><span>    </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>header</span><span style=color:#f29668>.</span><span>count </span><span style=color:#f29668>= </span><span style=color:#f29718>0
</span><span>} </span><span style=color:#f73>else </span><span>{
</span><span>    </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>header</span><span style=color:#f29668>.</span><span>count </span><span style=color:#f29668>+= </span><span style=color:#f29718>1 </span><span style=color:#5c6773;font-style:italic>//or fetch_add
</span><span>}
</span></code></pre><p>in <code>next_count</code>, which would inevitably lead to branch prediction misses.<p>Line 10 shows the only difference between the single and multi <code>Producer</code> cases. <code>count</code> is shared between all of the <code>Producers</code>, and we have to make sure no two <code>Producers</code> try to write to the same slot at the same time. By using <code>fetch_add</code> a <code>Producer</code> can both reserve a slot for his message, as well as advance the counter for other <code>Producers</code>.<blockquote><p>The only potential problem is that if another <code>Producer</code> manages to make it all the way around the <code>buffer</code> to the same slot, in the time that the first <code>Producer</code> is still writing the message. Then they might be writing to the same data at the same time. In reality it's clear that this never happens</blockquote><h2 id=consumer-implementation><a aria-label="Anchor link for: consumer-implementation" class=zola-anchor href=#consumer-implementation><code>Consumer</code> implementation</a></h2><p>As mentioned before, <code>Consumers</code> are be implemented such that only the <code>Seqlock</code> buffer is shared with other <code>Consumers</code> and <code>Producers</code>. We thus have to figure out a way for them to understand when the next message is ready, and wether they got sped past by a <code>producer</code>.<p>The <code>version</code> of the <code>SeqLocks</code> can be used for both given the following observations:<ol><li>the next message to be read will be in the slot whose <code>version</code> is lower than that of the previous slot<li>the version of the slot containing the next message to read will be exactly 2 more than before once the message is ready<li>the version of the <code>Seqlocks</code> can be fully deduced from the <code>count</code> of the queue: <code>(count / bufsize)</code> is how many times all <code>Seqlocks</code> have been written to and <code>count % bufsize</code> is the position of the next <code>Seqlock</code> to be written to</ol><p>Let's then first initialize a <code>Consumer</code> with the current <code>count</code> and the expected <code>version</code> of the <code>Seqlocks</code> holding messages to be read:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>repr</span><span>(C)]
</span><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>derive</span><span>(Debug)]
</span><span style=color:#f73>pub struct </span><span style=color:#59c2ff>Consumer</span><span><</span><span style=color:#f73>'a</span><span>, T> {
</span><span>    pos</span><span style=color:#bfbab0cc>:              </span><span style=color:#f73>usize</span><span>, </span><span style=color:#5c6773;font-style:italic>// 8
</span><span>    mask</span><span style=color:#bfbab0cc>:             </span><span style=color:#f73>usize</span><span>, </span><span style=color:#5c6773;font-style:italic>// 16
</span><span>    expected_version</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>usize</span><span>, </span><span style=color:#5c6773;font-style:italic>// 24
</span><span>    queue</span><span style=color:#bfbab0cc>:            </span><span style=color:#f29668>&</span><span style=color:#f73>'a </span><span>Queue&LTT>, </span><span style=color:#5c6773;font-style:italic>// 48 fat ptr: (usize, pointer)
</span><span>}
</span><span>
</span><span style=color:#f73>impl</span><span><</span><span style=color:#f73>'a</span><span>, T</span><span style=color:#bfbab0cc>: </span><span style=color:#39bae6;font-style:italic>Copy</span><span>> </span><span style=color:#39bae6;font-style:italic>From</span><span><</span><span style=color:#f29668>&</span><span style=color:#f73>'a </span><span>Queue&LTT>> </span><span style=color:#f73>for </span><span style=color:#59c2ff>Consumer</span><span><</span><span style=color:#f73>'a</span><span>, T> {
</span><span>    </span><span style=color:#f73>fn </span><span style=color:#ffb454>from</span><span>(</span><span style=color:#f29718>queue</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span style=color:#f73>'a </span><span>Queue&LTT>) </span><span style=color:#bfbab0cc>-> </span><span style=color:#f73>Self </span><span>{
</span><span>        </span><span style=color:#f73>let</span><span> mask </span><span style=color:#f29668>=</span><span> queue</span><span style=color:#f29668>.</span><span>header</span><span style=color:#f29668>.</span><span>mask</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#f73>let</span><span> c </span><span style=color:#f29668>=</span><span> queue</span><span style=color:#f29668>.</span><span>header</span><span style=color:#f29668>.</span><span>count</span><span style=color:#f29668>.</span><span style=color:#f07178>load</span><span>(std</span><span style=color:#f29668>::</span><span>sync</span><span style=color:#f29668>::</span><span>atomic</span><span style=color:#f29668>::</span><span>Ordering</span><span style=color:#f29668>::</span><span>Relaxed)</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#f73>let</span><span> pos </span><span style=color:#f29668>=</span><span> c </span><span style=color:#f29668>&</span><span> queue</span><span style=color:#f29668>.</span><span>header</span><span style=color:#f29668>.</span><span>mask</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#5c6773;font-style:italic>/* e.g.
</span><span style=color:#5c6773;font-style:italic>            seqlock_versions = [4, 2, 2, 2, 2, 2, 2, 2]
</span><span style=color:#5c6773;font-style:italic>                                   ^ next message, ready when version switches to 4
</span><span style=color:#5c6773;font-style:italic>            len = 8
</span><span style=color:#5c6773;font-style:italic>            count = 9
</span><span style=color:#5c6773;font-style:italic>            count / len = 9 / 8 = 1
</span><span style=color:#5c6773;font-style:italic>            1 << 1 = 2
</span><span style=color:#5c6773;font-style:italic>            expected_version = 2 + 2 = 4
</span><span style=color:#5c6773;font-style:italic>        */
</span><span>        </span><span style=color:#f73>let</span><span> expected_version </span><span style=color:#f29668>= </span><span>((queue</span><span style=color:#f29668>.</span><span>header</span><span style=color:#f29668>.</span><span>count </span><span style=color:#f29668>/ </span><span>(queue</span><span style=color:#f29668>.</span><span style=color:#f07178>len</span><span>())) </span><span style=color:#f29668><< </span><span style=color:#f29718>1</span><span>) </span><span style=color:#f29668>+ </span><span style=color:#f29718>2</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#f73>Self </span><span>{
</span><span>            pos</span><span style=color:#bfbab0cc>,
</span><span>            mask</span><span style=color:#bfbab0cc>,
</span><span>            expected_version</span><span style=color:#bfbab0cc>,
</span><span>            queue</span><span style=color:#bfbab0cc>,
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>A <code>Consumer</code> knows when the next message is ready to be read when the <code>Seqlock</code> <code>version</code> jumps to the <code>expected_version</code>, i.e. when a <code>Producer</code> has finished writing it.<p>A <code>Consumer</code> can also deduce when it is sped past when it sees that the <code>version</code> of the next message it tries to read is higher than the <code>expected_version</code>. The only way that this is posible is if a <code>Producer</code> wrote to the <code>Seqlock</code>, thereby incrementing the <code>version</code> to the expected one, then looping all the way around the <code>buffer</code> back to the same <code>Seqlock</code> and writing another message, thus incrementing the <code>version</code> to one higher than <code>expected_version</code>. When the slow <code>Consumer</code> finally comes along it will have lost the data of the overwritten message because it was sped past. At least with this implementation we know and choose how to deal with it.<p>A visual representation of the possible scenarios is shown in the following figure:<p><img title="Queue flow" alt src=https://louisponet.github.io/blog/posts/icc-2-queues-vectors/Queue.svg#noborder><p><em>Fig. 2: The operation flow of a <code>Producer</code> and <code>Consumer</code></em><p>We start by implementing a new <code>read_with_version</code> function on the <code>Seqlock</code>:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#f73>use </span><span>thiserror</span><span style=color:#f29668>::</span><span>Error</span><span style=color:#bfbab0cc>;
</span><span>
</span><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>derive</span><span>(Error</span><span style=color:#bfbab0cc>,</span><span> Debug</span><span style=color:#bfbab0cc>,</span><span> Copy</span><span style=color:#bfbab0cc>,</span><span> Clone</span><span style=color:#bfbab0cc>,</span><span> PartialEq)]
</span><span style=color:#f73>pub enum </span><span style=color:#59c2ff>ReadError </span><span>{
</span><span>    </span><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>error</span><span>(</span><span style=color:#c2d94c>"Got sped past"</span><span>)]
</span><span>    SpedPast</span><span style=color:#bfbab0cc>,
</span><span>    </span><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>error</span><span>(</span><span style=color:#c2d94c>"Queue empty"</span><span>)]
</span><span>    Empty</span><span style=color:#bfbab0cc>,
</span><span>}
</span><span>
</span><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>inline</span><span>(never)]
</span><span style=color:#f73>pub fn </span><span style=color:#ffb454>read_with_version</span><span>(
</span><span>    </span><span style=color:#f29668>&</span><span style=color:#f29718>self</span><span>,
</span><span>    </span><span style=color:#f29718>result</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span style=color:#f73>mut</span><span> T,
</span><span>    </span><span style=color:#f29718>expected_version</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>usize</span><span>,
</span><span>) </span><span style=color:#bfbab0cc>-> </span><span style=color:#39bae6;font-style:italic>Result</span><span><(), ReadError> {
</span><span>    </span><span style=color:#f73>loop </span><span>{
</span><span>        </span><span style=color:#f73>let</span><span> v1 </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>version</span><span style=color:#f29668>.</span><span style=color:#f07178>load</span><span>(Ordering</span><span style=color:#f29668>::</span><span>Acquire)</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#f73>if</span><span> v1 </span><span style=color:#f29668>!=</span><span> expected_version {
</span><span>            </span><span style=color:#f73>if</span><span> v1 </span><span style=color:#f29668><</span><span> expected_version {
</span><span>                </span><span style=color:#f73>return </span><span style=color:#39bae6;font-style:italic>Err</span><span>(ReadError</span><span style=color:#f29668>::</span><span>Empty)</span><span style=color:#bfbab0cc>;
</span><span>            } </span><span style=color:#f73>else </span><span>{
</span><span>                </span><span style=color:#f73>return </span><span style=color:#39bae6;font-style:italic>Err</span><span>(ReadError</span><span style=color:#f29668>::</span><span>SpedPast)</span><span style=color:#bfbab0cc>;
</span><span>            }
</span><span>        }
</span><span>
</span><span>        </span><span style=color:#f07178>compiler_fence</span><span>(Ordering</span><span style=color:#f29668>::</span><span>AcqRel)</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#f29668>*</span><span>result </span><span style=color:#f29668>= </span><span style=color:#f73>unsafe </span><span>{ </span><span style=color:#f29668>*</span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>data</span><span style=color:#f29668>.</span><span style=color:#f07178>get</span><span>() }</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#f07178>compiler_fence</span><span>(Ordering</span><span style=color:#f29668>::</span><span>AcqRel)</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#f73>let</span><span> v2 </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>version</span><span style=color:#f29668>.</span><span style=color:#f07178>load</span><span>(Ordering</span><span style=color:#f29668>::</span><span>Acquire)</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#f73>if</span><span> v1 </span><span style=color:#f29668>==</span><span> v2 {
</span><span>            </span><span style=color:#f73>return </span><span style=color:#39bae6;font-style:italic>Ok</span><span>(())</span><span style=color:#bfbab0cc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>The main difference to the previously discussed <a href=https://louisponet.github.io/blog/posts/icc-1-seqlock/#tl-dr><code>read</code></a> function is that we now know what <code>version</code> the <code>Consumer</code> expects. By returning <code>Result<(), ReadError></code>, the current situation is communicated back to the caller: either a message has succesfully been read (<code>Ok(())</code>), no message is ready yet (<code>Err(ReadError::Empty)</code>), or the <code>Consumer</code> was sped past (<code>Err(ReadError::SpedPast)</code>).<p>We implement the <code>try_read</code> function for the <code>Consumer</code> based on this:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#f73>fn </span><span style=color:#ffb454>update_pos</span><span>(</span><span style=color:#f29668>&</span><span style=color:#f73>mut </span><span style=color:#f29718>self</span><span>) {
</span><span>    </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>pos </span><span style=color:#f29668>= </span><span>(</span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>pos </span><span style=color:#f29668>+ </span><span style=color:#f29718>1</span><span>) </span><span style=color:#f29668>& </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>mask</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>expected_version </span><span style=color:#f29668>+= </span><span style=color:#f29718>2 </span><span style=color:#f29668>* </span><span>(</span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>pos </span><span style=color:#f29668>== </span><span style=color:#f29718>0</span><span>) </span><span style=color:#f29668>as </span><span style=color:#f73>usize</span><span style=color:#bfbab0cc>;
</span><span>}
</span><span>
</span><span style=color:#5c6773;font-style:italic>/// Nonblocking consume returning either Ok(()) or a ReadError
</span><span style=color:#f73>pub fn </span><span style=color:#ffb454>try_consume</span><span>(</span><span style=color:#f29668>&</span><span style=color:#f73>mut </span><span style=color:#f29718>self</span><span>, </span><span style=color:#f29718>el</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span style=color:#f73>mut</span><span> T) </span><span style=color:#bfbab0cc>-> </span><span style=color:#39bae6;font-style:italic>Result</span><span><(), ReadError> {
</span><span>    </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>queue</span><span style=color:#f29668>.</span><span style=color:#f07178>load</span><span>(</span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>pos)</span><span style=color:#f29668>.</span><span style=color:#f07178>read_with_version</span><span>(el</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>pos</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>expected_version)</span><span style=color:#f29668>?</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span style=color:#f07178>update_pos</span><span>()</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#39bae6;font-style:italic>Ok</span><span>(())
</span><span>}
</span></code></pre><h1 id=conclusion><a aria-label="Anchor link for: conclusion" class=zola-anchor href=#conclusion>Conclusion</a></h1><p>Boom, that's it for this installment folks! We have covered the main concepts behind how the <code>SeqlockVector</code> and <code>Queue</code> synchronization datastructures have been implemented in <strong>Mantra</strong>. These form the backbone that allow all systems to work together. We have implemented using the <code>Seqlocks</code> we have discussed in the previous post, and made them as self-sufficient as possible. As highlighted before, this helps with performance and overall robustness of the system.<p>Next time we will go about thorougly testing, benchmarking, and potentially optimizing the implementation, hope to see you there!.</section></article></main><div class=giscus></div><script async crossorigin data-category=Announcements data-category-id=DIC_kwDOL2wVKc4Cfndy data-emit-metadata=0 data-input-position=top data-lang=en data-mapping=pathname data-reactions-enabled=1 data-repo=louisponet/blog data-repo-id=R_kgDOL2wVKQ data-strict=0 data-theme=dark src=https://giscus.app/client.js></script></div>