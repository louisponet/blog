<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Inter Core Communication Pt 1: Seqlock
        
    </title><meta content="Inter Core Communication Pt 1: Seqlock" property=og:title><meta content="A thorough investigation of the main synchronization primitive used by Mantra: the Seqlock" property=og:description><meta content="A thorough investigation of the main synchronization primitive used by Mantra: the Seqlock" name=description><link href=/icon/favicon.svg rel=icon type=image/png><link href=https://louisponet.github.io/blog/fonts.css rel=stylesheet><script src=https://louisponet.github.io/blog/js/codeblock.js></script><script src=https://louisponet.github.io/blog/js/toc.js></script><script>MathJax={tex:{inlineMath:[[`\$`,`\$`],[`\\\\(`,`\\\\)`]]}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Louis Ponet" href=https://louisponet.github.io/blog/atom.xml rel=alternate type=application/atom+xml><link href=https://louisponet.github.io/blog/theme/light.css rel=stylesheet><link href=https://louisponet.github.io/blog/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://louisponet.github.io/blog/js/themetoggle.js></script><script>setTheme(getSavedTheme())</script><link href=https://louisponet.github.io/blog/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://louisponet.github.io/blog>Louis Ponet</a><div class=socials><a class=social href=https://github.com/louisponet/ rel=me> <img alt=github src=https://louisponet.github.io/blog/social_icons/github.svg> </a><a class=social href=https://www.linkedin.com/in/louis-ponet-phd-384ba0b6/ rel=me> <img alt=linkedin src=https://louisponet.github.io/blog/social_icons/linkedin.svg> </a><a href="https://scholar.google.com/citations?hl=en&user=oAp2Siow_v8C" class=social rel=me> <img alt=scholar src=https://louisponet.github.io/blog/social_icons/scholar.svg> </a><a href="mailto:louisponet@gmail.com?subject=Howdy%20from%20your%20blog" class=social rel=me> <img alt=email src=https://louisponet.github.io/blog/social_icons/email.svg> </a></div></div><nav><a href=https://louisponet.github.io/blog/posts style=margin-left:.5em>/posts</a><a href=https://louisponet.github.io/blog/about style=margin-left:.5em>/about</a><a href=https://louisponet.github.io/blog/tags style=margin-left:.5em>/tags</a> |<a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://louisponet.github.io/blog/feather/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://louisponet.github.io/blog/feather/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>Inter Core Communication Pt 1: Seqlock<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2024-05-25</time><span class=tags-label> :: Tags:</span><span class=tags> <a class=post-tag href=https://louisponet.github.io/blog/tags/mantra/>mantra</a>, <a class=post-tag href=https://louisponet.github.io/blog/tags/icc/>icc</a>, <a class=post-tag href=https://louisponet.github.io/blog/tags/seqlock/>seqlock</a> </span></div></div><div class=toc-container><h1 class=toc-title>Table of Contents</h1><ul class=toc-list><li><a href=https://louisponet.github.io/blog/posts/icc-1-seqlock/#design-goals-and-considerations>Design Goals and Considerations</a><li><a href=https://louisponet.github.io/blog/posts/icc-1-seqlock/#seqlock>Seqlock</a><li><a href=https://louisponet.github.io/blog/posts/icc-1-seqlock/#tl-dr>TL;DR</a><li><a href=https://louisponet.github.io/blog/posts/icc-1-seqlock/#are-memory-barriers-necessary>Are memory barriers necessary?</a> <ul><li><a href=https://louisponet.github.io/blog/posts/icc-1-seqlock/#torn-data-testing>Torn data testing</a><li><a href=https://louisponet.github.io/blog/posts/icc-1-seqlock/#inline-and-compiler-cleverness>Inline, and Compiler Cleverness</a><li><a href=https://louisponet.github.io/blog/posts/icc-1-seqlock/#deeper-dive-using-cargo-asm>Deeper dive using cargo asm</a></li><ul><li><a href=https://louisponet.github.io/blog/posts/icc-1-seqlock/#seqlock-usize-1024-read>Seqlock::<[usize; 1024]>::read</a><li><a href=https://louisponet.github.io/blog/posts/icc-1-seqlock/#seqlock-usize-1-read>Seqlock::<[usize; 1]>::read</a><li><a href=https://louisponet.github.io/blog/posts/icc-1-seqlock/#adding-memory-barriers>Adding Memory Barriers</a></ul></ul><li><a href=https://louisponet.github.io/blog/posts/icc-1-seqlock/#performance>Performance</a> <ul><li><a href=https://louisponet.github.io/blog/posts/icc-1-seqlock/#timing-101>Timing 101</a><li><a href=https://louisponet.github.io/blog/posts/icc-1-seqlock/#baseline-inter-core-latency>Baseline Inter Core Latency</a><li><a href=https://louisponet.github.io/blog/posts/icc-1-seqlock/#seqlock-performance>Seqlock performance</a></li><ul><li><a href=https://louisponet.github.io/blog/posts/icc-1-seqlock/#starting-point>Starting Point</a><li><a href=https://louisponet.github.io/blog/posts/icc-1-seqlock/#optimization>Optimization</a></ul></ul><li><a href=https://louisponet.github.io/blog/posts/icc-1-seqlock/#possible-future-investigations-improvements>Possible future investigations/improvements</a></ul></div><section class=body><p>As the first technical topic in this blog, I will discuss the main method of synchronizing the inter core communication used in <a href=https://louisponet.github.io/blog/posts/hello-world/><strong>Mantra</strong></a>: a <code>Seqlock</code>. It forms the fundamental building block for the "real" communication datastructures: <code>Queues</code> and <code>SeqlockVectors</code>, which will be the topic of the next blog post.<p>I have chosen the <code>Seqlock</code> because it is a lock-free synchronization primitive that is simple and should be capable of achieving almost the ideal core-to-core latency. Moreover, reading from the <code>Seqlock</code> does not require taking a lock at all. The worst case is that a <code>Consumer</code> needs to read multiple times until the <code>Producer</code> is done writing. This favors <code>Producers</code> over <code>Consumers</code> and also makes <code>Consumers</code> not impact eachother. This is ideal for a low-latency trading system, since we do not want a single <code>Consumer</code> or <code>Produce</code> that fails or is slow to bring the whole system to a halt.<p>I will start by getting straight to the final implemenation for those in a hurry.<p>We then continue with the whys behind that implementation. First we discuss how to verify the correctness of a <code>Seqlock</code> implementation. This will demonstrate how the concept of memory barriers is necessary to make it reliable. We investigate this by designing tests, observing the potential pitfalls of function inlining, looking at some assembly code (funky), and strong-arming the compiler to do our bidding.<p>Finally, we go through a quick 101 on low-latency timing followed by an investigation into the performance of our implementation.<p>Before continuing, I would like to give major credit to everyone involved with creating the following inspirational material<ul><li><a href="https://www.youtube.com/watch?v=8uAW5FQtcvE">Trading at light speed</a><li>An amazing set of references: <a href=https://github.com/rigtorp/awesome-lockfree>Awesome Lockfree</a><li><a href="https://www.youtube.com/watch?v=ZQFzMfHIxng">C++ atomics, from basic to advanced. What do they really do?</a></ul><h1 id=design-goals-and-considerations><a aria-label="Anchor link for: design-goals-and-considerations" class=zola-anchor href=#design-goals-and-considerations>Design Goals and Considerations</a></h1><ul><li>Achieve a close to the ideal ~30-40ns core-to-core latency (see e.g. <a href=https://www.anandtech.com/show/17601/intel-core-i9-13900k-and-i5-13600k-review/5>anandtech 13900k and 13600k review</a> and the <a href=https://github.com/nviennot/core-to-core-latency>fantastic core-to-core-latency tool</a>)<li>data <code>Producers</code> do not care about and are not impacted by data <code>Consumers</code><li><code>Consumers</code> should not impact eachother</ul><h1 id=seqlock><a aria-label="Anchor link for: seqlock" class=zola-anchor href=#seqlock>Seqlock</a></h1><p>The embodiment of the above goals in terms of synchronization techniques is the <code>Seqlock</code> (see <a href=https://en.wikipedia.org/wiki/Seqlock>Wikipedia</a>, <a href=https://docs.kernel.org/locking/seqlock.html>seqlock in the linux kernel</a>, and <a href=https://github.com/rigtorp/Seqlock>Erik Rigtorp's C++11 implementation</a>).<p>The key points are:<ul><li>A <code>Producer</code> (or writer) is never blocked by <code>Consumers</code> (readers)<li>The <code>Producer</code> atomically increments a counter (the <code>Seq</code> in <code>Seqlock</code>) once before and once after writing the data<li><code>counter & 1 == 0</code> (even) communicates to <code>Consumers</code> that they can read data<li><code>counter_before_read == counter_after_read</code>: data remained consistent while reading<li>Compare and swap could be used on the counter to allow multiple <code>Producers</code> to write to same <code>Seqlock</code><li>Compilers and cpus in general can't be trusted, making it crucial to verify that the execution sequence indeed follows the steps we instructed. Memory barriers and fences are required to guarantee this in general</ul><h1 id=tl-dr><a aria-label="Anchor link for: tl-dr" class=zola-anchor href=#tl-dr>TL;DR</a></h1><p>Out of solidarity with your scroll wheel and without further ado:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>derive</span><span>(Default)]
</span><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>repr</span><span>(</span><span style=color:#ffb454>align</span><span>(64))]
</span><span style=color:#f73>pub struct </span><span style=color:#59c2ff>Seqlock</span><span>&LTT> {
</span><span>    version</span><span style=color:#bfbab0cc>:</span><span> AtomicUsize,
</span><span>    data</span><span style=color:#bfbab0cc>: </span><span>UnsafeCell&LTT>,
</span><span>}
</span><span style=color:#f73>unsafe impl</span><span>&LTT</span><span style=color:#bfbab0cc>: </span><span style=color:#39bae6;font-style:italic>Send</span><span>> Send </span><span style=color:#f73>for </span><span style=color:#59c2ff>Seqlock</span><span>&LTT> {}
</span><span style=color:#f73>unsafe impl</span><span>&LTT</span><span style=color:#bfbab0cc>: </span><span style=color:#39bae6;font-style:italic>Sync</span><span>> Sync </span><span style=color:#f73>for </span><span style=color:#59c2ff>Seqlock</span><span>&LTT> {}
</span><span>
</span><span style=color:#f73>impl</span><span>&LTT</span><span style=color:#bfbab0cc>: </span><span style=color:#39bae6;font-style:italic>Copy</span><span>> </span><span style=color:#59c2ff>Seqlock</span><span>&LTT> {
</span><span>    </span><span style=color:#f73>pub fn </span><span style=color:#ffb454>new</span><span>(</span><span style=color:#f29718>data</span><span style=color:#bfbab0cc>:</span><span> T) </span><span style=color:#bfbab0cc>-> </span><span style=color:#f73>Self </span><span>{
</span><span>        </span><span style=color:#f73>Self </span><span>{version</span><span style=color:#bfbab0cc>: </span><span>AtomicUsize</span><span style=color:#f29668>::</span><span>new(</span><span style=color:#f29718>0</span><span>)</span><span style=color:#bfbab0cc>,</span><span> data</span><span style=color:#bfbab0cc>: </span><span>UnsafeCell</span><span style=color:#f29668>::</span><span>new(data)}
</span><span>    }
</span><span>    </span><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>inline</span><span>(never)]
</span><span>    </span><span style=color:#f73>pub fn </span><span style=color:#ffb454>read</span><span>(</span><span style=color:#f29668>&</span><span style=color:#f29718>self</span><span>, </span><span style=color:#f29718>result</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span style=color:#f73>mut</span><span> T) {
</span><span>        </span><span style=color:#f73>loop </span><span>{
</span><span>            </span><span style=color:#f73>let</span><span> v1 </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>version</span><span style=color:#f29668>.</span><span style=color:#f07178>load</span><span>(Ordering</span><span style=color:#f29668>::</span><span>Acquire)</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=color:#f07178>compiler_fence</span><span>(Ordering</span><span style=color:#f29668>::</span><span>AcqRel)</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=color:#f29668>*</span><span>result </span><span style=color:#f29668>= </span><span style=color:#f73>unsafe </span><span>{ </span><span style=color:#f29668>*</span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>data</span><span style=color:#f29668>.</span><span style=color:#f07178>get</span><span>() }</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=color:#f07178>compiler_fence</span><span>(Ordering</span><span style=color:#f29668>::</span><span>AcqRel)</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=color:#f73>let</span><span> v2 </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>version</span><span style=color:#f29668>.</span><span style=color:#f07178>load</span><span>(Ordering</span><span style=color:#f29668>::</span><span>Acquire)</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=color:#f73>if</span><span> v1 </span><span style=color:#f29668>==</span><span> v2 </span><span style=color:#f29668>&&</span><span> v1 </span><span style=color:#f29668>& </span><span style=color:#f29718>1 </span><span style=color:#f29668>== </span><span style=color:#f29718>0 </span><span>{
</span><span>                </span><span style=color:#f73>return</span><span style=color:#bfbab0cc>;
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>inline</span><span>(never)]
</span><span>    </span><span style=color:#f73>pub fn </span><span style=color:#ffb454>write</span><span>(</span><span style=color:#f29668>&</span><span style=color:#f29718>self</span><span>, </span><span style=color:#f29718>val</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>T) {
</span><span>        </span><span style=color:#f73>let</span><span> v </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>version</span><span style=color:#f29668>.</span><span style=color:#f07178>fetch_add</span><span>(</span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>, </span><span>Ordering</span><span style=color:#f29668>::</span><span>Release)</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#f07178>compiler_fence</span><span>(Ordering</span><span style=color:#f29668>::</span><span>AcqRel)</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#f73>unsafe </span><span>{ </span><span style=color:#f29668>*</span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>data</span><span style=color:#f29668>.</span><span style=color:#f07178>get</span><span>() </span><span style=color:#f29668>= *</span><span>val }</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#f07178>compiler_fence</span><span>(Ordering</span><span style=color:#f29668>::</span><span>AcqRel)</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>version</span><span style=color:#f29668>.</span><span style=color:#f07178>store</span><span>(v</span><span style=color:#f29668>.</span><span style=color:#f07178>wrapping_add</span><span>(</span><span style=color:#f29718>2</span><span>)</span><span style=color:#bfbab0cc>, </span><span>Ordering</span><span style=color:#f29668>::</span><span>Release)</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>}
</span></code></pre><p>That's it, till next time folks!<h1 id=are-memory-barriers-necessary><a aria-label="Anchor link for: are-memory-barriers-necessary" class=zola-anchor href=#are-memory-barriers-necessary>Are memory barriers necessary?</a></h1><p>Most literature on <code>Seqlocks</code> focuses (rightly so) on guaranteeing correctness.<p>The first potential problem is that the stored <code>data</code> does not depend on the <code>version</code> of the <code>Seqlock</code>. This allows the compiler to merge or reorder the two increments to the <code>version</code> in the <code>write</code> function. The same goes for the checks on <code>v1</code> and <code>v2</code> on the <code>read</code> side of things.<p>It potentially gets worse, though: depending on the architecture of the cpu, read and write memory operations to <code>version</code> and <code>data</code> could be reordered <strong>on the hardware level</strong>.<p>Given that the <code>Seqlock's</code> correctness depends entirely on the sequence of <code>version</code> increments and checks around <code>data</code> writes and reads, these issues are big no-nos.<p>As we will investigate further below, memory barriers are the main solution to these issues. They keep the compiler in line by guaranteeing <a href=https://en.cppreference.com/w/cpp/atomic/memory_order>certain things</a>, forcing it to adhere to the sequence of instructions that we specified in the code. The same applies to the cpu itself.<p>For x86 cpus, these barriers luckily do not require any <em>additional</em> cpu instructions, just that no instructions are reordered or ommitted. x86 cpus are <a href=https://www.cl.cam.ac.uk/~pes20/weakmemory/cacm.pdf>strongly memory ordered</a>, meaning that they guarantee the following: writes to some memory (i.e. <code>version</code>) can not be reordered with writes to other memory (i.e. <code>data</code>), and similar for reads. Other cpu architectures might require additional cpu instructions to enforce these guarantees. However, as long as we include the barriers, the <code>rust</code> compiler can figure out the rest.<p>See the <a href=https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering>Release-Acquire ordering section in the c++ reference</a> for further information on the specific barrier construction that is used in the <code>Seqlock</code>.<h2 id=torn-data-testing><a aria-label="Anchor link for: torn-data-testing" class=zola-anchor href=#torn-data-testing>Torn data testing</a></h2><p>The first concern that we can relatively easily verify is data consistency. In the test below we verify that when a <code>Consumer</code> supposedly succesfully reads <code>data</code>, the <code>Producer</code> was indeed not simultaneously writing to it. We do this by making a <code>Producer</code> fill and write an array with an increasing counter, while a <code>Consumer</code> reads and verifies that all entries in the array are identical (see the highlighted line below). If reading and writing were to happen at the same time, the <code>Consumer</code> would at some point see partially new and partially old data with differing counter values. This would make the test fail.<pre class=language-rust data-lang=rust data-linenos style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><table><tbody><tr><td>1<td><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>cfg</span><span>(test)]
</span><tr><td>2<td><span style=color:#f73>mod </span><span style=color:#59c2ff>tests </span><span>{
</span><tr><td>3<td><span>    </span><span style=color:#f73>use super</span><span style=color:#f29668>::*</span><span style=color:#bfbab0cc>;
</span><tr><td>4<td><span>    </span><span style=color:#f73>use </span><span>std</span><span style=color:#f29668>::</span><span>{sync</span><span style=color:#f29668>::</span><span>atomic</span><span style=color:#f29668>::</span><span>AtomicBool</span><span style=color:#bfbab0cc>, </span><span>time</span><span style=color:#f29668>::</span><span>{Duration</span><span style=color:#bfbab0cc>,</span><span> Instant}}</span><span style=color:#bfbab0cc>;
</span><tr><td>5<td><span>
</span><tr><td>6<td><span>    </span><span style=color:#f73>fn </span><span style=color:#ffb454>consumer_loop</span><span><</span><span style=color:#f73>const</span><span> N</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>usize</span><span>>(</span><span style=color:#f29718>lock</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>Seqlock<[</span><span style=color:#f73>usize</span><span style=color:#bfbab0cc>;</span><span>N]>, </span><span style=color:#f29718>done</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>AtomicBool) {
</span><tr><td>7<td><span>        </span><span style=color:#f73>let mut</span><span> msg </span><span style=color:#f29668>= </span><span>[</span><span style=color:#f29718>0</span><span style=color:#f73>usize</span><span style=color:#bfbab0cc>;</span><span> N]</span><span style=color:#bfbab0cc>;
</span><tr><td>8<td><span>        </span><span style=color:#f73>while </span><span style=color:#f29668>!</span><span>done</span><span style=color:#f29668>.</span><span style=color:#f07178>load</span><span>(Ordering</span><span style=color:#f29668>::</span><span>Relaxed) {
</span><tr><td><mark style=background-color:#0a0e12>9</mark><td><mark style=background-color:#0a0e12><span>            lock</span><span style=color:#f29668>.</span><span style=color:#f07178>read</span><span>(</span><span style=color:#f29668>&</span><span style=color:#f73>mut</span><span> msg)</span><span style=color:#bfbab0cc>;
</span></mark><tr><td><mark style=background-color:#0a0e12>10</mark><td><mark style=background-color:#0a0e12><span>            </span><span style=color:#f73>let</span><span> first </span><span style=color:#f29668>=</span><span> msg[</span><span style=color:#f29718>0</span><span>]</span><span style=color:#bfbab0cc>;
</span></mark><tr><td>11<td><span>            </span><span style=color:#f73>for</span><span> i </span><span style=color:#f29668>in</span><span> msg {
</span><tr><td><mark style=background-color:#0a0e12>12</mark><td><mark style=background-color:#0a0e12><span>                </span><span style=color:#f07178>assert_eq!</span><span>(first</span><span style=color:#bfbab0cc>,</span><span> i)</span><span style=color:#bfbab0cc>;
</span></mark><tr><td>13<td><span>            }
</span><tr><td>14<td><span>        }
</span><tr><td>15<td><span>    }
</span><tr><td>16<td><span>
</span><tr><td>17<td><span>    </span><span style=color:#f73>fn </span><span style=color:#ffb454>producer_loop</span><span><</span><span style=color:#f73>const</span><span> N</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>usize</span><span>>(</span><span style=color:#f29718>lock</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>Seqlock<[</span><span style=color:#f73>usize</span><span style=color:#bfbab0cc>;</span><span>N]>, </span><span style=color:#f29718>done</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>AtomicBool) {
</span><tr><td>18<td><span>        </span><span style=color:#f73>let</span><span> curt </span><span style=color:#f29668>= </span><span>Instant</span><span style=color:#f29668>::</span><span>now()</span><span style=color:#bfbab0cc>;
</span><tr><td>19<td><span>        </span><span style=color:#f73>let mut</span><span> count </span><span style=color:#f29668>= </span><span style=color:#f29718>0</span><span style=color:#bfbab0cc>;
</span><tr><td>20<td><span>        </span><span style=color:#f73>let mut</span><span> msg </span><span style=color:#f29668>= </span><span>[</span><span style=color:#f29718>0</span><span style=color:#f73>usize</span><span style=color:#bfbab0cc>;</span><span> N]</span><span style=color:#bfbab0cc>;
</span><tr><td>21<td><span>        </span><span style=color:#f73>while</span><span> curt</span><span style=color:#f29668>.</span><span style=color:#f07178>elapsed</span><span>() </span><span style=color:#f29668>< </span><span>Duration</span><span style=color:#f29668>::</span><span>from_secs(</span><span style=color:#f29718>1</span><span>) {
</span><tr><td><mark style=background-color:#0a0e12>22</mark><td><mark style=background-color:#0a0e12><span>            msg</span><span style=color:#f29668>.</span><span style=color:#f07178>fill</span><span>(count)</span><span style=color:#bfbab0cc>;
</span></mark><tr><td><mark style=background-color:#0a0e12>23</mark><td><mark style=background-color:#0a0e12><span>            lock</span><span style=color:#f29668>.</span><span style=color:#f07178>write</span><span>(</span><span style=color:#f29668>&</span><span>msg)</span><span style=color:#bfbab0cc>;
</span></mark><tr><td>24<td><span>            count </span><span style=color:#f29668>=</span><span> count</span><span style=color:#f29668>.</span><span style=color:#f07178>wrapping_add</span><span>(</span><span style=color:#f29718>1</span><span>)</span><span style=color:#bfbab0cc>;
</span><tr><td>25<td><span>        }
</span><tr><td>26<td><span>        done</span><span style=color:#f29668>.</span><span style=color:#f07178>store</span><span>(</span><span style=color:#f29718>true</span><span style=color:#bfbab0cc>, </span><span>Ordering</span><span style=color:#f29668>::</span><span>Relaxed)</span><span style=color:#bfbab0cc>;
</span><tr><td>27<td><span>    }
</span><tr><td>28<td><span>
</span><tr><td>29<td><span>    </span><span style=color:#f73>fn </span><span style=color:#ffb454>read_test</span><span><</span><span style=color:#f73>const</span><span> N</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>usize</span><span>>()
</span><tr><td>30<td><span>    {
</span><tr><td>31<td><span>        </span><span style=color:#f73>let</span><span> lock </span><span style=color:#f29668>= </span><span>Seqlock</span><span style=color:#f29668>::</span><span>new([</span><span style=color:#f29718>0</span><span style=color:#f73>usize</span><span style=color:#bfbab0cc>;</span><span> N])</span><span style=color:#bfbab0cc>;
</span><tr><td>32<td><span>        </span><span style=color:#f73>let</span><span> done </span><span style=color:#f29668>= </span><span>AtomicBool</span><span style=color:#f29668>::</span><span>new(</span><span style=color:#f29718>false</span><span>)</span><span style=color:#bfbab0cc>;
</span><tr><td>33<td><span>        std</span><span style=color:#f29668>::</span><span>thread</span><span style=color:#f29668>::</span><span>scope(|</span><span style=color:#f29718>s</span><span>| {
</span><tr><td>34<td><span>            s</span><span style=color:#f29668>.</span><span style=color:#f07178>spawn</span><span>(|| {
</span><tr><td>35<td><span>                </span><span style=color:#f07178>consumer_loop</span><span>(</span><span style=color:#f29668>&</span><span>lock</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668>&</span><span>done)</span><span style=color:#bfbab0cc>;
</span><tr><td>36<td><span>            })</span><span style=color:#bfbab0cc>;
</span><tr><td>37<td><span>            s</span><span style=color:#f29668>.</span><span style=color:#f07178>spawn</span><span>(|| {
</span><tr><td>38<td><span>                </span><span style=color:#f07178>producer_loop</span><span>(</span><span style=color:#f29668>&</span><span>lock</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668>&</span><span>done)</span><span style=color:#bfbab0cc>;
</span><tr><td>39<td><span>            })</span><span style=color:#bfbab0cc>;
</span><tr><td>40<td><span>        })</span><span style=color:#bfbab0cc>;
</span><tr><td>41<td><span>    }
</span><tr><td>42<td><span>
</span><tr><td>43<td><span>    </span><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>test</span><span>]
</span><tr><td>44<td><span>    </span><span style=color:#f73>fn </span><span style=color:#ffb454>read_16</span><span>() {
</span><tr><td>45<td><span>        read_test</span><span style=color:#f29668>::</span><span>&LT16>()
</span><tr><td>46<td><span>    }
</span><tr><td>47<td><span>    </span><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>test</span><span>]
</span><tr><td>48<td><span>    </span><span style=color:#f73>fn </span><span style=color:#ffb454>read_32</span><span>() {
</span><tr><td>49<td><span>        read_test</span><span style=color:#f29668>::</span><span>&LT32>()
</span><tr><td>50<td><span>    }
</span><tr><td>51<td><span>    </span><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>test</span><span>]
</span><tr><td>52<td><span>    </span><span style=color:#f73>fn </span><span style=color:#ffb454>read_64</span><span>() {
</span><tr><td>53<td><span>        read_test</span><span style=color:#f29668>::</span><span>&LT64>()
</span><tr><td>54<td><span>    }
</span><tr><td>55<td><span>    </span><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>test</span><span>]
</span><tr><td>56<td><span>    </span><span style=color:#f73>fn </span><span style=color:#ffb454>read_128</span><span>() {
</span><tr><td>57<td><span>        read_test</span><span style=color:#f29668>::</span><span>&LT128>()
</span><tr><td>58<td><span>    }
</span><tr><td>59<td><span>    </span><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>test</span><span>]
</span><tr><td>60<td><span>    </span><span style=color:#f73>fn </span><span style=color:#ffb454>read_large</span><span>() {
</span><tr><td>61<td><span>        read_test</span><span style=color:#f29668>::</span><span>&LT65536>()
</span><tr><td>62<td><span>    }
</span><tr><td>63<td><span>}
</span></table></code></pre><p>If I run these tests on an intel i9 14900k, using the following simplified <code>read</code> and <code>write</code> implementations without memory barriers<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#f73>pub fn </span><span style=color:#ffb454>read</span><span>(</span><span style=color:#f29668>&</span><span style=color:#f29718>self</span><span>, </span><span style=color:#f29718>result</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span style=color:#f73>mut</span><span> T) {
</span><span>    </span><span style=color:#f73>loop </span><span>{
</span><span>        </span><span style=color:#f73>let</span><span> v1 </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>version</span><span style=color:#f29668>.</span><span style=color:#f07178>load</span><span>(Ordering</span><span style=color:#f29668>::</span><span>Relaxed)</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#f29668>*</span><span>result </span><span style=color:#f29668>= </span><span style=color:#f73>unsafe </span><span>{ </span><span style=color:#f29668>*</span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>data</span><span style=color:#f29668>.</span><span style=color:#f07178>get</span><span>() }</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#f73>let</span><span> v2 </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>version</span><span style=color:#f29668>.</span><span style=color:#f07178>load</span><span>(Ordering</span><span style=color:#f29668>::</span><span>Relaxed)</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#f73>if</span><span> v1 </span><span style=color:#f29668>==</span><span> v2 </span><span style=color:#f29668>&&</span><span> v1 </span><span style=color:#f29668>& </span><span style=color:#f29718>1 </span><span style=color:#f29668>== </span><span style=color:#f29718>0 </span><span>{
</span><span>            </span><span style=color:#f73>return</span><span style=color:#bfbab0cc>;
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#f73>pub fn </span><span style=color:#ffb454>write</span><span>(</span><span style=color:#f29668>&</span><span style=color:#f29718>self</span><span>, </span><span style=color:#f29718>val</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>T) {
</span><span>    </span><span style=color:#f73>let</span><span> v </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>version</span><span style=color:#f29668>.</span><span style=color:#f07178>load</span><span>(Ordering</span><span style=color:#f29668>::</span><span>Relaxed)</span><span style=color:#f29668>.</span><span style=color:#f07178>wrapping_add</span><span>(</span><span style=color:#f29718>1</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>version</span><span style=color:#f29668>.</span><span style=color:#f07178>store</span><span>(v</span><span style=color:#bfbab0cc>, </span><span>Ordering</span><span style=color:#f29668>::</span><span>Relaxed)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f73>unsafe </span><span>{ </span><span style=color:#f29668>*</span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>data</span><span style=color:#f29668>.</span><span style=color:#f07178>get</span><span>() </span><span style=color:#f29668>= *</span><span>val }</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>version</span><span style=color:#f29668>.</span><span style=color:#f07178>store</span><span>(v</span><span style=color:#f29668>.</span><span style=color:#f07178>wrapping_add</span><span>(</span><span style=color:#f29718>1</span><span>)</span><span style=color:#bfbab0cc>, </span><span>Ordering</span><span style=color:#f29668>::</span><span>Relaxed)</span><span style=color:#bfbab0cc>;
</span><span>}
</span></code></pre><p>I find that they fail for array sizes of 64 (512 bytes) and up. This signals that the compiler did some reordering of operations.<h2 id=inline-and-compiler-cleverness><a aria-label="Anchor link for: inline-and-compiler-cleverness" class=zola-anchor href=#inline-and-compiler-cleverness>Inline, and Compiler Cleverness</a></h2><p>Funnily enough, barriers are not necessarily needed to fix these tests. Yeah, I also was not happy that my illustrating example in fact does not illustrate what I was trying to illustrate.<p>Nonetheless, I chose to mention it because it highlights just how much the compiler will mangle your code if you let it. I will not paste the resulting assembly here as it is rather lengthy (see <a href=https://godbolt.org/z/7MYaW7Pba>assembly lines (23, 50-303) on godbolt</a>). The crux is that the compiler chose to inline the <code>read</code> function and then decided to move the <code>let first = msg[0]</code> statement of line (10) entirely before the <code>while</code> loop...<p>Strange? Maybe not. The compiler's reasoning here is actually similar to the one that requires us to use memory barriers. The essential point is, again, that the <code>data</code> field inside the <code>Seqlock</code> is not an atomic variable like <code>version</code>. This allows the compiler to assume that only the current thread touches it. Meanwhile, the <code>Consumer</code> thread never writes to <code>data</code>, so it never changes, right? Ha, might as well just set <code>first = data[0]</code> once and for all before starting with the actual <code>read</code> & verify loop. Of course, the reality is that the <code>Producer</code> is actually changing <code>data</code>. Thus, as soon as the <code>Consumer</code> thread <code>reads</code> it into <code>msg</code>, <code>first != msg[i]</code> causing our test to fail.<p>Interestingly, adding <code>assert_ne!(msg[0], 0)</code> after line (14) seems to make the compiler less sure about this code transformation because suddenly all tests pass. Looking at the resulting assembly confirms this observation as now line (10) is correctly executed each loop after first reading the <code>Seqlock</code>.<p>The first step towards provable correctness of the <code>Seqlock</code> is thus to add <code>#[inline(never)]</code> to the <code>read</code> and <code>write</code> functions.<h2 id=deeper-dive-using-cargo-asm><a aria-label="Anchor link for: deeper-dive-using-cargo-asm" class=zola-anchor href=#deeper-dive-using-cargo-asm>Deeper dive using <a href=https://crates.io/crates/cargo-show-asm/0.2.34><code>cargo asm</code></a></a></h2><p>I kind of jumped the gun above with respect to reading compiler produced assembly. The tool I use by far the most for this is <code>cargo asm</code>. It can be easily installed using <code>cargo</code> and has a very user friendly terminal based interface. <a href=https://godbolt.org>godbolt</a> is another great choice, but it can become tedious to copy-paste all the supporting code when working on a larger codebase. In either case, I recommend adding <code>#[inline(never)]</code> to the function of interest so its assembly can be more easily filtered out.<p>Let's see what the compiler generates for the <code>read</code> function of a couple different array sizes.<h3 id=seqlock-usize-1024-read><a aria-label="Anchor link for: seqlock-usize-1024-read" class=zola-anchor href=#seqlock-usize-1024-read><code>Seqlock::<[usize; 1024]>::read</code></a></h3><p>When using a large array with 1024 elements, the assembly reads<pre class=language-asm data-lang=asm data-linenos style=color:#bfbab0;background-color:#0f1419><code class=language-asm data-lang=asm><table><tbody><tr><td>1<td><span style=color:#ffb454>code::Seqlock&LTT>::read:
</span><tr><td>2<td><span style=color:#ffb454>        .cfi_startproc
</span><tr><td>3<td><span style=color:#ffb454>        </span><span style=color:#f73>push </span><span style=color:#f29718>r15
</span><tr><td>4<td><span style=color:#ffb454>        .cfi_def_cfa_offset </span><span style=color:#f29718>16
</span><tr><td>5<td><span style=color:#ffb454>        </span><span style=color:#f73>push </span><span style=color:#f29718>r14
</span><tr><td>6<td><span style=color:#ffb454>        .cfi_def_cfa_offset </span><span style=color:#f29718>24
</span><tr><td>7<td><span style=color:#ffb454>        </span><span style=color:#f73>push </span><span style=color:#f29718>r12
</span><tr><td>8<td><span style=color:#ffb454>        .cfi_def_cfa_offset </span><span style=color:#f29718>32
</span><tr><td>9<td><span style=color:#ffb454>        </span><span style=color:#f73>push </span><span style=color:#f29718>rbx
</span><tr><td>10<td><span style=color:#ffb454>        .cfi_def_cfa_offset </span><span style=color:#f29718>40
</span><tr><td>11<td><span style=color:#ffb454>        </span><span style=color:#f73>push </span><span style=color:#f29718>rax
</span><tr><td>12<td><span style=color:#ffb454>        .cfi_def_cfa_offset </span><span style=color:#f29718>48
</span><tr><td>13<td><span style=color:#ffb454>        .cfi_offset </span><span style=color:#f29718>rbx</span><span>, -</span><span style=color:#f29718>40
</span><tr><td>14<td><span style=color:#ffb454>        .cfi_offset </span><span style=color:#f29718>r12</span><span>, -</span><span style=color:#f29718>32
</span><tr><td>15<td><span style=color:#ffb454>        .cfi_offset </span><span style=color:#f29718>r14</span><span>, -</span><span style=color:#f29718>24
</span><tr><td>16<td><span style=color:#ffb454>        .cfi_offset </span><span style=color:#f29718>r15</span><span>, -</span><span style=color:#f29718>16
</span><tr><td>17<td><span style=color:#ffb454>        </span><span style=color:#f73>mov </span><span style=color:#f29718>rbx</span><span>, </span><span style=color:#f29718>rsi
</span><tr><td>18<td><span style=color:#ffb454>        </span><span style=color:#f73>mov </span><span style=color:#f29718>r14</span><span>, </span><span style=color:#f29718>rdi
</span><tr><td><mark style=background-color:#0a0e12>19</mark><td><mark style=background-color:#0a0e12><span style=color:#ffb454>        </span><span style=color:#f73>mov </span><span style=color:#f29718>r15</span><span>, </span><span style=color:#f07178>qword ptr </span><span>[</span><span style=color:#f29718>rip </span><span>+ </span><span style=color:#ffb454>memcpy@GOTPCREL</span><span>]
</span></mark><tr><td>20<td><span style=color:#ffb454>        .p2align        </span><span style=color:#f29718>4</span><span>, </span><span style=color:#f29718>0x90
</span><tr><td>21<td><span style=color:#ffb454>.LBB6_1:
</span><tr><td><mark style=background-color:#0a0e12>22</mark><td><mark style=background-color:#0a0e12><span style=color:#ffb454>        </span><span style=color:#f73>mov </span><span style=color:#f29718>r12</span><span>, </span><span style=color:#f07178>qword ptr </span><span>[</span><span style=color:#f29718>r14 </span><span>+ </span><span style=color:#f29718>8192</span><span>]
</span></mark><tr><td>23<td><span style=color:#ffb454>        </span><span style=color:#f73>mov </span><span style=color:#f29718>edx</span><span>, </span><span style=color:#f29718>8192
</span><tr><td>24<td><span style=color:#ffb454>        </span><span style=color:#f73>mov </span><span style=color:#f29718>rdi</span><span>, </span><span style=color:#f29718>rbx
</span><tr><td>25<td><span style=color:#ffb454>        </span><span style=color:#f73>mov </span><span style=color:#f29718>rsi</span><span>, </span><span style=color:#f29718>r14
</span><tr><td><mark style=background-color:#0a0e12>26</mark><td><mark style=background-color:#0a0e12><span style=color:#ffb454>        </span><span style=color:#f73>call </span><span style=color:#f29718>r15
</span></mark><tr><td><mark style=background-color:#0a0e12>27</mark><td><mark style=background-color:#0a0e12><span style=color:#ffb454>        </span><span style=color:#f73>mov </span><span style=color:#f29718>rax</span><span>, </span><span style=color:#f07178>qword ptr </span><span>[</span><span style=color:#f29718>r14 </span><span>+ </span><span style=color:#f29718>8192</span><span>]
</span></mark><tr><td><mark style=background-color:#0a0e12>28</mark><td><mark style=background-color:#0a0e12><span style=color:#ffb454>        </span><span style=color:#f73>test </span><span style=color:#f29718>r12b</span><span>, </span><span style=color:#f29718>1
</span></mark><tr><td>29<td><span style=color:#ffb454>        </span><span style=color:#f73>jne </span><span style=color:#ffb454>.LBB6_1
</span><tr><td><mark style=background-color:#0a0e12>30</mark><td><mark style=background-color:#0a0e12><span style=color:#ffb454>        </span><span style=color:#f73>cmp </span><span style=color:#f29718>r12</span><span>, </span><span style=color:#f29718>rax
</span></mark><tr><td>31<td><span style=color:#ffb454>        </span><span style=color:#f73>jne </span><span style=color:#ffb454>.LBB6_1
</span><tr><td>32<td><span style=color:#ffb454>        </span><span style=color:#f73>add </span><span style=color:#f29718>rsp</span><span>, </span><span style=color:#f29718>8
</span><tr><td>33<td><span style=color:#ffb454>        .cfi_def_cfa_offset </span><span style=color:#f29718>40
</span><tr><td>34<td><span style=color:#ffb454>        </span><span style=color:#f73>pop </span><span style=color:#f29718>rbx
</span><tr><td>35<td><span style=color:#ffb454>        .cfi_def_cfa_offset </span><span style=color:#f29718>32
</span><tr><td>36<td><span style=color:#ffb454>        </span><span style=color:#f73>pop </span><span style=color:#f29718>r12
</span><tr><td>37<td><span style=color:#ffb454>        .cfi_def_cfa_offset </span><span style=color:#f29718>24
</span><tr><td>38<td><span style=color:#ffb454>        </span><span style=color:#f73>pop </span><span style=color:#f29718>r14
</span><tr><td>39<td><span style=color:#ffb454>        .cfi_def_cfa_offset </span><span style=color:#f29718>16
</span><tr><td>40<td><span style=color:#ffb454>        </span><span style=color:#f73>pop </span><span style=color:#f29718>r15
</span><tr><td>41<td><span style=color:#ffb454>        .cfi_def_cfa_offset </span><span style=color:#f29718>8
</span><tr><td>42<td><span style=color:#ffb454>        </span><span style=color:#f73>ret
</span></table></code></pre><p>The first thing we observe in lines (19, 22, 27) is that the compiler chose not to adhere to the ordering of fields in our definition of the <code>Seqlock</code>, moving <code>version</code> behind <code>data</code>. If needed, the order of fields can be preserved by adding <code>#[repr(C)]</code>.<p>The operational part of the <code>read</code> function is, instead, almost one-to-one translated into assembly:<ol><li>assign function pointer to <code>memcpy</code> to <code>r15</code> for faster future calling<li>move <code>version</code> at <code>Seqlock start (r14) + 8192 bytes</code> into <code>r12</code><li>perform the <code>memcpy</code><li>move <code>version</code> at <code>Seqlock start (r14) + 8192 bytes</code> into <code>rax</code><li>check <code>r12 & 1 == 0</code><li>check <code>r12 == rax</code><li>Profit...</ol><h3 id=seqlock-usize-1-read><a aria-label="Anchor link for: seqlock-usize-1-read" class=zola-anchor href=#seqlock-usize-1-read><code>Seqlock::<[usize; 1]>::read</code></a></h3><p>For smaller array sizes we get<pre class=language-asm data-lang=asm data-linenos style=color:#bfbab0;background-color:#0f1419><code class=language-asm data-lang=asm><table><tbody><tr><td>1<td><span style=color:#ffb454>code::Seqlock&LTT>::read:
</span><tr><td>2<td><span style=color:#ffb454>        .cfi_startproc
</span><tr><td>3<td><span style=color:#ffb454>        </span><span style=color:#f73>mov </span><span style=color:#f29718>rax</span><span>, </span><span style=color:#f07178>qword ptr </span><span>[</span><span style=color:#f29718>rdi </span><span>+ </span><span style=color:#f29718>8</span><span>]
</span><tr><td>4<td><span style=color:#ffb454>        .p2align        </span><span style=color:#f29718>4</span><span>, </span><span style=color:#f29718>0x90
</span><tr><td>5<td><span style=color:#ffb454>.LBB6_1:
</span><tr><td>6<td><span style=color:#ffb454>        </span><span style=color:#f73>mov </span><span style=color:#f29718>rcx</span><span>, </span><span style=color:#f07178>qword ptr </span><span>[</span><span style=color:#f29718>rdi</span><span>]
</span><tr><td>7<td><span style=color:#ffb454>        </span><span style=color:#f73>mov </span><span style=color:#f29718>rdx</span><span>, </span><span style=color:#f07178>qword ptr </span><span>[</span><span style=color:#f29718>rdi</span><span>]
</span><tr><td>8<td><span style=color:#ffb454>        </span><span style=color:#f73>test </span><span style=color:#f29718>cl</span><span>, </span><span style=color:#f29718>1
</span><tr><td>9<td><span style=color:#ffb454>        </span><span style=color:#f73>jne </span><span style=color:#ffb454>.LBB6_1
</span><tr><td>10<td><span style=color:#ffb454>        </span><span style=color:#f73>cmp </span><span style=color:#f29718>rcx</span><span>, </span><span style=color:#f29718>rdx
</span><tr><td>11<td><span style=color:#ffb454>        </span><span style=color:#f73>jne </span><span style=color:#ffb454>.LBB6_1
</span><tr><td>12<td><span style=color:#ffb454>        </span><span style=color:#f73>mov </span><span style=color:#f07178>qword ptr </span><span>[</span><span style=color:#f29718>rsi</span><span>], </span><span style=color:#f29718>rax
</span><tr><td>13<td><span style=color:#ffb454>        </span><span style=color:#f73>ret
</span></table></code></pre><p>Well at least it looks clean... I'm pretty sure I don't have to underline the issue with steps<ol><li>Do the copy of <code>data</code> into <code>rax</code><li>move <code>version</code> into <code>rcx</code>... and <code>rdx</code>?<li>test <code>version & 1 != 1</code><li>test <code>rcx == rdx</code>... hol' on, what?<li>copy from <code>rax</code> into the input<li>wait a minute...</ol><p>This is a good demonstration of why tests should not be blindly trusted and why double checking the produced assembly is good practice. In fact, I never got the tests to fail after adding the <code>#[inline(never)]</code> discussed earlier, even though the assembly clearly shows that nothing stops a <code>read</code> while a <code>write</code> is happening. This happens because the <code>memcpy</code> is done <strong>inline/in cache</strong> for small enough <code>data</code>, using moves between cache and registers (<code>rax</code> in this case). If a single instruction is used (<code>mov</code> here) it is never possible that the data is partially overwritten while reading, and it remains highly unlikely even when multiple instructions are required.<h3 id=adding-memory-barriers><a aria-label="Anchor link for: adding-memory-barriers" class=zola-anchor href=#adding-memory-barriers>Adding Memory Barriers</a></h3><p>Here we go:<pre class=language-rust data-lang=rust data-linenos style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><table><tbody><tr><td>1<td><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>inline</span><span>(never)]
</span><tr><td>2<td><span style=color:#f73>pub fn </span><span style=color:#ffb454>read</span><span>(</span><span style=color:#f29668>&</span><span style=color:#f29718>self</span><span>, </span><span style=color:#f29718>result</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span style=color:#f73>mut</span><span> T) {
</span><tr><td>3<td><span>    </span><span style=color:#f73>loop </span><span>{
</span><tr><td>4<td><span>        </span><span style=color:#f73>let</span><span> v1 </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>version</span><span style=color:#f29668>.</span><span style=color:#f07178>load</span><span>(Ordering</span><span style=color:#f29668>::</span><span>Acquire)</span><span style=color:#bfbab0cc>;
</span><tr><td>5<td><span>        </span><span style=color:#f07178>compiler_fence</span><span>(Ordering</span><span style=color:#f29668>::</span><span>AcqRel)</span><span style=color:#bfbab0cc>;
</span><tr><td>6<td><span>        </span><span style=color:#f29668>*</span><span>result </span><span style=color:#f29668>= </span><span style=color:#f73>unsafe </span><span>{ </span><span style=color:#f29668>*</span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>data</span><span style=color:#f29668>.</span><span style=color:#f07178>get</span><span>() }</span><span style=color:#bfbab0cc>;
</span><tr><td>7<td><span>        </span><span style=color:#f07178>compiler_fence</span><span>(Ordering</span><span style=color:#f29668>::</span><span>AcqRel)</span><span style=color:#bfbab0cc>;
</span><tr><td>8<td><span>        </span><span style=color:#f73>let</span><span> v2 </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>version</span><span style=color:#f29668>.</span><span style=color:#f07178>load</span><span>(Ordering</span><span style=color:#f29668>::</span><span>Acquire)</span><span style=color:#bfbab0cc>;
</span><tr><td>9<td><span>        </span><span style=color:#f73>if</span><span> v1 </span><span style=color:#f29668>==</span><span> v2 </span><span style=color:#f29668>&&</span><span> v1 </span><span style=color:#f29668>& </span><span style=color:#f29718>1 </span><span style=color:#f29668>== </span><span style=color:#f29718>0 </span><span>{
</span><tr><td>10<td><span>            </span><span style=color:#f73>return</span><span style=color:#bfbab0cc>;
</span><tr><td>11<td><span>        }
</span><tr><td>12<td><span>    }
</span><tr><td>13<td><span>}
</span></table></code></pre><pre class=language-asm data-lang=asm data-linenos style=color:#bfbab0;background-color:#0f1419><code class=language-asm data-lang=asm><table><tbody><tr><td>1<td><span style=color:#ffb454>code::Seqlock&LTT>::read:
</span><tr><td>2<td><span style=color:#ffb454>        .cfi_startproc
</span><tr><td>3<td><span style=color:#ffb454>        .p2align        </span><span style=color:#f29718>4</span><span>, </span><span style=color:#f29718>0x90
</span><tr><td>4<td><span style=color:#ffb454>.LBB6_1:
</span><tr><td>5<td><span style=color:#ffb454>        </span><span style=color:#f73>mov </span><span style=color:#f29718>rax</span><span>, </span><span style=color:#f07178>qword ptr </span><span>[</span><span style=color:#f29718>rdi</span><span>]
</span><tr><td>6<td><span style=color:#ffb454>        #MEMBARRIER
</span><tr><td>7<td><span style=color:#ffb454>        </span><span style=color:#f73>mov </span><span style=color:#f29718>rcx</span><span>, </span><span style=color:#f07178>qword ptr </span><span>[</span><span style=color:#f29718>rdi </span><span>+ </span><span style=color:#f29718>8</span><span>]
</span><tr><td>8<td><span style=color:#ffb454>        </span><span style=color:#f73>mov </span><span style=color:#f07178>qword ptr </span><span>[</span><span style=color:#f29718>rsi</span><span>], </span><span style=color:#f29718>rcx
</span><tr><td>9<td><span style=color:#ffb454>        #MEMBARRIER
</span><tr><td>10<td><span style=color:#ffb454>        </span><span style=color:#f73>mov </span><span style=color:#f29718>rcx</span><span>, </span><span style=color:#f07178>qword ptr </span><span>[</span><span style=color:#f29718>rdi</span><span>]
</span><tr><td>11<td><span style=color:#ffb454>        </span><span style=color:#f73>test </span><span style=color:#f29718>al</span><span>, </span><span style=color:#f29718>1
</span><tr><td>12<td><span style=color:#ffb454>        </span><span style=color:#f73>jne </span><span style=color:#ffb454>.LBB6_1
</span><tr><td>13<td><span style=color:#ffb454>        </span><span style=color:#f73>cmp </span><span style=color:#f29718>rax</span><span>, </span><span style=color:#f29718>rcx
</span><tr><td>14<td><span style=color:#ffb454>        </span><span style=color:#f73>jne </span><span style=color:#ffb454>.LBB6_1
</span><tr><td>15<td><span style=color:#ffb454>        </span><span style=color:#f73>ret
</span></table></code></pre><p>It is interesting to see that the compiler chooses to reuse <code>rcx</code> both for the data copy in lines (5) and (6), as well as the second <code>version</code> load in line (8).<p>With the current <code>rust</code> compiler (1.78.0), I found that only adding <code>Ordering::Acquire</code> in lines (4) or (7) of the <code>rust</code> code already does the trick. However, they only guarantee the ordering of loads of the atomic <code>version</code> when combined with an <code>Ordering::Release</code> store in the <code>write</code> function, not when the actual <code>data</code> is copied in relation to it. That is where the <code>compiler_fence</code> comes in, guaranteeing also this ordering. As discussed before, adding these extra barriers in the code did not change the performance on x86.<p>The corresponding <code>write</code> function becomes:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>inline</span><span>(never)]
</span><span style=color:#f73>pub fn </span><span style=color:#ffb454>write</span><span>(</span><span style=color:#f29668>&</span><span style=color:#f29718>self</span><span>, </span><span style=color:#f29718>val</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>T) {
</span><span>    </span><span style=color:#f73>let</span><span> v </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>version</span><span style=color:#f29668>.</span><span style=color:#f07178>load</span><span>(Ordering</span><span style=color:#f29668>::</span><span>Relaxed)</span><span style=color:#f29668>.</span><span style=color:#f07178>wrapping_add</span><span>(</span><span style=color:#f29718>1</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>version</span><span style=color:#f29668>.</span><span style=color:#f07178>store</span><span>(v</span><span style=color:#bfbab0cc>, </span><span>Ordering</span><span style=color:#f29668>::</span><span>Release)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f07178>compiler_fence</span><span>(Ordering</span><span style=color:#f29668>::</span><span>AcqRel)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f73>unsafe </span><span>{ </span><span style=color:#f29668>*</span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>data</span><span style=color:#f29668>.</span><span style=color:#f07178>get</span><span>() </span><span style=color:#f29668>= *</span><span>val }</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f07178>compiler_fence</span><span>(Ordering</span><span style=color:#f29668>::</span><span>AcqRel)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>version</span><span style=color:#f29668>.</span><span style=color:#f07178>store</span><span>(v</span><span style=color:#f29668>.</span><span style=color:#f07178>wrapping_add</span><span>(</span><span style=color:#f29718>1</span><span>)</span><span style=color:#bfbab0cc>, </span><span>Ordering</span><span style=color:#f29668>::</span><span>Release)</span><span style=color:#bfbab0cc>;
</span><span>}
</span></code></pre><p>Our <code>Seqlock</code> implementation should now be correct, and is pretty much identical to others that can be found in the wild.<p>Having now understood a thing or two about memory barriers while solidifying our <code>Seqlock</code>, we turn to an aspect that is covered much less frequently: timing and potentially optimizing the implementation. Granted, there is not much room to play with here given the size of the functions. Nevertheless, some of the key concepts that I will discuss in the process will be used in many future posts.<p>P.S.: if memory models and barriers are really your schtick, live a little and marvel your way through <a href=https://docs.kernel.org/core-api/wrappers/memory-barriers.html>The Linux Kernel Docs on Memory Barriers</a>.<h1 id=performance><a aria-label="Anchor link for: performance" class=zola-anchor href=#performance>Performance</a></h1><p>THe main question we will answer is: Does the <code>fetch_add</code> make the <code>write</code> function of the <a href=https://louisponet.github.io/blog/posts/icc-1-seqlock/#tl-dr>final implementation</a> indeed faster?<h2 id=timing-101><a aria-label="Anchor link for: timing-101" class=zola-anchor href=#timing-101>Timing 101</a></h2><p>The full details regarding the suite of timing and performance measurements tools I have developed to track the performance of <a href=https://louisponet.github.io/blog/posts/hello-world/><strong>Mantra</strong></a> will be divulged in a later post.<p>For now, the key points are:<p><strong>Use <code>rdtscp</code> to take timestamps</strong>: the <code>rdtscp</code> hardware counter is a monotonously increasing cpu cycle counter (at base frequency) which is reset upon startup. What's even better is that on recent cpus it is shared between all cores (look for <code>constant_tsc</code> in <code>/proc/cpuinfo</code>). It is the cheapest, at ~5ns overhead, and most precise way to take timestamps. Another benefit for our usecase is that it also partially orders operations (see discussion above). It will not execute until <em>"all previous instructions have executed and all previous loads are globally visible"</em>, see <a href=https://www.felixcloutier.com/x86/rdtscp>this</a>. Using an <code>_mm_lfence</code> after the initial <code>rdtscp</code> will also force executions to not start before the timestamp is taken. This is <strong>the only reasonable way</strong> to time on really low latency scales.<p><strong>use <a href=https://docs.rs/core_affinity/latest/core_affinity/><code>core_affinity</code></a> and <code>isolcpus</code></strong>: The combination of the <a href=https://wiki.linuxfoundation.org/realtime/documentation/howto/tools/cpu-partitioning/isolcpus><code>isolcpus</code></a> kernel parameter with binding a thread in <code>rust</code> to a specific core allows us to minimize jitter coming from whatever else is running on the computer. The p-cores on my cpu have been isolated for our testing purposes below. See <a href=https://rigtorp.se/low-latency-guide/>Erik Rigtorp's low latency tuning guide</a> for even more info.<p><strong>Offload the actual timing</strong>: To minimize the timing overheadl, we take the two <code>rdtscp</code> stamps and offload them to a <code>Queue</code> in shared memory (more on what a <code>Queue</code> is later). Another process can then read these messages, collect statistics and convert <code>rdtscp</code> stamp deltas to nanoseconds (in the i9 14900k case x3.2). For this last step we can actually reuse the <a href=https://docs.rs/quanta/latest/quanta/struct.Clock.html#method.delta_as_nanos><code>nanos_from_raw_delta</code></a> function in the <code>quanta</code> library.<p>Putting it all together, a block of code can be timed like:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#f73>let</span><span> t1 </span><span style=color:#f29668>= </span><span style=color:#f73>unsafe </span><span>{ </span><span style=color:#f07178>__rdtscp</span><span>(</span><span style=color:#f29668>&</span><span style=color:#f73>mut </span><span style=color:#f29718>0</span><span style=color:#f73>u32 </span><span style=color:#f29668>as </span><span style=color:#f73>*mut </span><span style=color:#f29668>_</span><span>) }</span><span style=color:#bfbab0cc>;
</span><span style=color:#f73>unsafe </span><span>{ </span><span style=color:#f07178>_mm_lfence</span><span>() }</span><span style=color:#bfbab0cc>;
</span><span style=color:#5c6773;font-style:italic>// code to be timed
</span><span style=color:#f73>let</span><span> t2 </span><span style=color:#f29668>= </span><span style=color:#f73>unsafe </span><span>{ </span><span style=color:#f07178>__rdtscp</span><span>(</span><span style=color:#f29668>&</span><span style=color:#f73>mut </span><span style=color:#f29718>0</span><span style=color:#f73>u32 </span><span style=color:#f29668>as </span><span style=color:#f73>*mut </span><span style=color:#f29668>_</span><span>) }</span><span style=color:#bfbab0cc>;
</span><span>timer_queue</span><span style=color:#f29668>.</span><span style=color:#f07178>produce</span><span>((t1</span><span style=color:#bfbab0cc>,</span><span> t2))</span><span style=color:#bfbab0cc>;
</span></code></pre><p>or, using my timing library<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#f73>let mut</span><span> timer </span><span style=color:#f29668>= </span><span>Timer</span><span style=color:#f29668>::</span><span>new(</span><span style=color:#c2d94c>"my_cool_timer"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>timer</span><span style=color:#f29668>.</span><span style=color:#f07178>start</span><span>()</span><span style=color:#bfbab0cc>;
</span><span style=color:#5c6773;font-style:italic>//code to be timed
</span><span>timer</span><span style=color:#f29668>.</span><span style=color:#f07178>stop</span><span>()</span><span style=color:#bfbab0cc>;
</span></code></pre><p>with an added functionality where you can use a previously taken <code>rdtscp</code> timestamp to measure a <code>latency</code>:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span>timer</span><span style=color:#f29668>.</span><span style=color:#f07178>latency</span><span>(prev_rdtscp)</span><span style=color:#bfbab0cc>;
</span></code></pre><p>The former will be called <code>Business</code> timing (for business logic), and the latter, you guessed it, <code>Latency</code> timing.<p>Throughout the following discussion we'll use a small tui tool I've created called <code>timekeeper</code> that ingests and displays these timing results:<p><img alt src=https://louisponet.github.io/blog/posts/icc-1-seqlock/timekeeper_example.png#noborder title=timekeeper_example> <em>Fig 1. Timekeeper example</em><h2 id=baseline-inter-core-latency><a aria-label="Anchor link for: baseline-inter-core-latency" class=zola-anchor href=#baseline-inter-core-latency>Baseline Inter Core Latency</a></h2><p>After isolating cpus, turning off hyperthreading, doing some more of the low latency tuning steps and switching to the <code>performance</code> governor, I've ran the following basic ping/pong code to provide us with some baseline latency timings:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>repr</span><span>(</span><span style=color:#ffb454>align</span><span>(64))]
</span><span style=color:#f73>struct </span><span style=color:#59c2ff>Test</span><span>(AtomicI32)</span><span style=color:#bfbab0cc>;
</span><span>
</span><span style=color:#f73>fn </span><span style=color:#ffb454>one_way_2_lines</span><span>(</span><span style=color:#f29718>n_samples</span><span style=color:#bfbab0cc>:</span><span style=color:#f73>usize</span><span>) {
</span><span>    </span><span style=color:#f73>let</span><span> seq1 </span><span style=color:#f29668>=</span><span> Test(AtomicI32</span><span style=color:#f29668>::</span><span>new(</span><span style=color:#f29668>-</span><span style=color:#f29718>1</span><span>))</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f73>let</span><span> seq2 </span><span style=color:#f29668>=</span><span> Test(AtomicI32</span><span style=color:#f29668>::</span><span>new(</span><span style=color:#f29668>-</span><span style=color:#f29718>1</span><span>))</span><span style=color:#bfbab0cc>;
</span><span>    std</span><span style=color:#f29668>::</span><span>thread</span><span style=color:#f29668>::</span><span>scope(|</span><span style=color:#f29718>s</span><span>| {
</span><span>        s</span><span style=color:#f29668>.</span><span style=color:#f07178>spawn</span><span>(|| {
</span><span>            core_affinity</span><span style=color:#f29668>::</span><span>set_for_current(CoreId { id</span><span style=color:#bfbab0cc>: </span><span style=color:#f29718>2</span><span>})</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=color:#f73>for </span><span style=color:#f29668>_ in </span><span style=color:#f29718>0</span><span style=color:#f29668>..</span><span>n_samples {
</span><span>                </span><span style=color:#f73>for</span><span> n </span><span style=color:#f29668>in </span><span style=color:#f29718>0</span><span style=color:#f29668>..</span><span style=color:#f29718>10000 </span><span>{
</span><span>                    </span><span style=color:#f73>while</span><span> seq1</span><span style=color:#f29668>.</span><span style=color:#f29718>0.</span><span style=color:#f07178>load</span><span>(Ordering</span><span style=color:#f29668>::</span><span>Acquire) </span><span style=color:#f29668>!=</span><span> n {}
</span><span>                    seq2</span><span style=color:#f29668>.</span><span style=color:#f29718>0.</span><span style=color:#f07178>store</span><span>(n</span><span style=color:#bfbab0cc>, </span><span>Ordering</span><span style=color:#f29668>::</span><span>Release)</span><span style=color:#bfbab0cc>;
</span><span>                }
</span><span>            }
</span><span>        })</span><span style=color:#bfbab0cc>;
</span><span>        s</span><span style=color:#f29668>.</span><span style=color:#f07178>spawn</span><span>(|| {
</span><span>            </span><span style=color:#f73>let mut</span><span> timer </span><span style=color:#f29668>= </span><span>Timer</span><span style=color:#f29668>::</span><span>new(</span><span style=color:#c2d94c>"one_way_2_lines"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>            core_affinity</span><span style=color:#f29668>::</span><span>set_for_current(CoreId { id</span><span style=color:#bfbab0cc>: </span><span style=color:#f29718>3 </span><span>})</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=color:#f73>for </span><span style=color:#f29668>_ in </span><span style=color:#f29718>0</span><span style=color:#f29668>..</span><span>n_samples {
</span><span>                </span><span style=color:#f73>for</span><span> n </span><span style=color:#f29668>in </span><span style=color:#f29718>0</span><span style=color:#f29668>..</span><span style=color:#f29718>10000 </span><span>{
</span><span>                    timer</span><span style=color:#f29668>.</span><span style=color:#f07178>start</span><span>()</span><span style=color:#bfbab0cc>;
</span><span>                    seq1</span><span style=color:#f29668>.</span><span style=color:#f29718>0.</span><span style=color:#f07178>store</span><span>(n</span><span style=color:#bfbab0cc>, </span><span>Ordering</span><span style=color:#f29668>::</span><span>Release)</span><span style=color:#bfbab0cc>;
</span><span>                    </span><span style=color:#f73>while</span><span> seq2</span><span style=color:#f29668>.</span><span style=color:#f29718>0.</span><span style=color:#f07178>load</span><span>(Ordering</span><span style=color:#f29668>::</span><span>Acquire) </span><span style=color:#f29668>!=</span><span> n {}
</span><span>                    timer</span><span style=color:#f29668>.</span><span style=color:#f07178>stop</span><span>()</span><span style=color:#bfbab0cc>;
</span><span>                }
</span><span>            }
</span><span>        })</span><span style=color:#bfbab0cc>;
</span><span>    })</span><span style=color:#bfbab0cc>;
</span><span>}
</span></code></pre><p>The <code>"2_lines"</code> stands for the fact that we are communicating through atomics <code>seq1</code> and <code>seq2</code> with each their own cacheline: i.e. <code>#[repr(align(64))]</code>. Running the code multiple times leads to:<p><img alt src=https://louisponet.github.io/blog/posts/icc-1-seqlock/one_way_2_lines.png#noborder title=baseline_inter_core> <em>Fig 2. Base line core-core latency</em><p>Bear in mind that the real latency is half of what is measured since these are round trip times.<p>The steps with different but constant average timings showcases the main difficulty with timing low level/low latency constructs: the cpu is essentially a black box and does a lot of memory and cache related wizardry behind the scenes to implement the <a href=https://en.wikipedia.org/wiki/MESI_protocol>MESI protocol</a>. Combining this with branch prediction renders the final result quite dependent on the exact execution starting times of the threads, leading to different but stable averages each run.<p>Anyway, the lower end of these measurements serves as a sanity check and target for our <code>Seqlock</code> latency.<h2 id=seqlock-performance><a aria-label="Anchor link for: seqlock-performance" class=zola-anchor href=#seqlock-performance>Seqlock performance</a></h2><p>When using <code>Seqlocks</code> the <code>Queues</code>, the scenario is that <code>Producers</code> 99% of the time do not produce anything. This causes the <code>Consumers</code> to essentially busy spin on the <code>Seqlock</code> associated with the next message to read.<p>We reflect this in the timing code's setup:<ul><li>a <code>Producer</code> writes an <code>rdtscp</code> timestamp into the <code>Seqlock</code> every 2 microseconds<li>a <code>Consumer</code> busy spins reading this timestamp<li>if it changes, the <code>Consumer</code> publishes a timing and latency measurement using the <code>rdtscp</code> value of the message as the starting point<li>0 or more "contender" <code>Consumers</code> do the same to see how increasing <code>Consumer</code> contention impacts the main <code>Producer</code> and <code>Consumer</code></ul><pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>derive</span><span>(Clone</span><span style=color:#bfbab0cc>,</span><span> Copy)]
</span><span style=color:#f73>struct </span><span style=color:#59c2ff>TimingMessage </span><span>{
</span><span>    rdtscp</span><span style=color:#bfbab0cc>:</span><span> Instant,
</span><span>    data</span><span style=color:#bfbab0cc>:</span><span>   [</span><span style=color:#f73>u8</span><span>; 1],
</span><span>}
</span><span>
</span><span style=color:#f73>fn </span><span style=color:#ffb454>contender</span><span>(</span><span style=color:#f29718>lock</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>Seqlock&LTTimingMessage>)
</span><span>{
</span><span>    </span><span style=color:#f73>let mut</span><span> m </span><span style=color:#f29668>=</span><span> TimingMessage { rdtscp</span><span style=color:#bfbab0cc>: </span><span>Instant</span><span style=color:#f29668>::</span><span>now()</span><span style=color:#bfbab0cc>,</span><span> data</span><span style=color:#bfbab0cc>: </span><span>[</span><span style=color:#f29718>0</span><span>]}</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f73>while</span><span> m</span><span style=color:#f29668>.</span><span>data[</span><span style=color:#f29718>0</span><span>] </span><span style=color:#f29668>== </span><span style=color:#f29718>0 </span><span>{
</span><span>        lock</span><span style=color:#f29668>.</span><span style=color:#f07178>read</span><span>(</span><span style=color:#f29668>&</span><span style=color:#f73>mut</span><span> m)</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#f73>fn </span><span style=color:#ffb454>timed_consumer</span><span>(</span><span style=color:#f29718>lock</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>Seqlock&LTTimingMessage>)
</span><span>{
</span><span>    </span><span style=color:#f73>let mut</span><span> timer </span><span style=color:#f29668>= </span><span>Timer</span><span style=color:#f29668>::</span><span>new(</span><span style=color:#c2d94c>"read"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    core_affinity</span><span style=color:#f29668>::</span><span>set_for_current(CoreId { id</span><span style=color:#bfbab0cc>: </span><span style=color:#f29718>1 </span><span>})</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f73>let mut</span><span> m </span><span style=color:#f29668>=</span><span> TimingMessage { rdtscp</span><span style=color:#bfbab0cc>: </span><span>Instant</span><span style=color:#f29668>::</span><span>now()</span><span style=color:#bfbab0cc>,</span><span> data</span><span style=color:#bfbab0cc>: </span><span>[</span><span style=color:#f29718>0</span><span>]}</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f73>let mut</span><span> last </span><span style=color:#f29668>=</span><span> m</span><span style=color:#f29668>.</span><span>rdtscp</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f73>while</span><span> m</span><span style=color:#f29668>.</span><span>data[</span><span style=color:#f29718>0</span><span>] </span><span style=color:#f29668>== </span><span style=color:#f29718>0 </span><span>{
</span><span>        timer</span><span style=color:#f29668>.</span><span style=color:#f07178>start</span><span>()</span><span style=color:#bfbab0cc>;
</span><span>        lock</span><span style=color:#f29668>.</span><span style=color:#f07178>read</span><span>(</span><span style=color:#f29668>&</span><span style=color:#f73>mut</span><span> m)</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#f73>if</span><span> m</span><span style=color:#f29668>.</span><span>rdtscp </span><span style=color:#f29668>!=</span><span> last {
</span><span>            timer</span><span style=color:#f29668>.</span><span style=color:#f07178>stop</span><span>()</span><span style=color:#bfbab0cc>;
</span><span>            timer</span><span style=color:#f29668>.</span><span style=color:#f07178>latency_till_stop</span><span>(m</span><span style=color:#f29668>.</span><span>rdtscp)</span><span style=color:#bfbab0cc>;
</span><span>        }
</span><span>        last </span><span style=color:#f29668>=</span><span> m</span><span style=color:#f29668>.</span><span>rdtscp</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#f73>fn </span><span style=color:#ffb454>producer</span><span>(</span><span style=color:#f29718>lock</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>Seqlock&LTTimingMessage>)
</span><span>{
</span><span>    </span><span style=color:#f73>let mut</span><span> timer </span><span style=color:#f29668>= </span><span>Timer</span><span style=color:#f29668>::</span><span>new(</span><span style=color:#c2d94c>"write"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    core_affinity</span><span style=color:#f29668>::</span><span>set_for_current(CoreId { id</span><span style=color:#bfbab0cc>: </span><span style=color:#f29718>2 </span><span>})</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f73>let mut</span><span> m </span><span style=color:#f29668>=</span><span> TimingMessage { rdtscp</span><span style=color:#bfbab0cc>: </span><span>Instant</span><span style=color:#f29668>::</span><span>now()</span><span style=color:#bfbab0cc>,</span><span> data</span><span style=color:#bfbab0cc>: </span><span>[</span><span style=color:#f29718>0</span><span>]}</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f73>let</span><span> curt </span><span style=color:#f29668>= </span><span>Instant</span><span style=color:#f29668>::</span><span>now()</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f73>while</span><span> curt</span><span style=color:#f29668>.</span><span style=color:#f07178>elapsed</span><span>() </span><span style=color:#f29668>< </span><span>Nanos</span><span style=color:#f29668>::</span><span>from_secs(</span><span style=color:#f29718>5</span><span>) {
</span><span>        timer</span><span style=color:#f29668>.</span><span style=color:#f07178>start</span><span>()</span><span style=color:#bfbab0cc>;
</span><span>        m</span><span style=color:#f29668>.</span><span>rdtscp </span><span style=color:#f29668>= </span><span>Instant</span><span style=color:#f29668>::</span><span>now()</span><span style=color:#bfbab0cc>;
</span><span>        lock</span><span style=color:#f29668>.</span><span style=color:#f07178>write</span><span>(</span><span style=color:#f29668>&</span><span>m)</span><span style=color:#bfbab0cc>;
</span><span>        timer</span><span style=color:#f29668>.</span><span style=color:#f07178>stop</span><span>()</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#f73>let</span><span> curt </span><span style=color:#f29668>= </span><span>Instant</span><span style=color:#f29668>::</span><span>now()</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#f73>while </span><span>Instant</span><span style=color:#f29668>::</span><span>now() </span><span style=color:#f29668>-</span><span> curt </span><span style=color:#f29668>< </span><span>Nanos</span><span style=color:#f29668>::</span><span>from_micros(</span><span style=color:#f29718>2</span><span>) {}
</span><span>    }
</span><span>    m</span><span style=color:#f29668>.</span><span>data[</span><span style=color:#f29718>0</span><span>] </span><span style=color:#f29668>= </span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>;
</span><span>    lock</span><span style=color:#f29668>.</span><span style=color:#f07178>write</span><span>(</span><span style=color:#f29668>&</span><span>m)</span><span style=color:#bfbab0cc>;
</span><span>}
</span><span>
</span><span style=color:#f73>fn </span><span style=color:#ffb454>consumer_latency</span><span>(</span><span style=color:#f29718>n_contenders</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>usize</span><span>) {
</span><span>    </span><span style=color:#f73>let</span><span> lock </span><span style=color:#f29668>= </span><span>Seqlock</span><span style=color:#f29668>::</span><span>default()</span><span style=color:#bfbab0cc>;
</span><span>    std</span><span style=color:#f29668>::</span><span>thread</span><span style=color:#f29668>::</span><span>scope(|</span><span style=color:#f29718>s</span><span>| {
</span><span>        </span><span style=color:#f73>for</span><span> i </span><span style=color:#f29668>in </span><span style=color:#f29718>1</span><span style=color:#f29668>..</span><span>(n_contenders </span><span style=color:#f29668>+ </span><span style=color:#f29718>1</span><span>) {
</span><span>            </span><span style=color:#f73>let</span><span> lck </span><span style=color:#f29668>= &</span><span>lock</span><span style=color:#bfbab0cc>;
</span><span>            s</span><span style=color:#f29668>.</span><span style=color:#f07178>spawn</span><span>(</span><span style=color:#f73>move </span><span style=color:#f29668>|| </span><span>{
</span><span>                core_affinity</span><span style=color:#f29668>::</span><span>set_for_current(CoreId { id</span><span style=color:#bfbab0cc>:</span><span> i </span><span style=color:#f29668>+ </span><span style=color:#f29718>2 </span><span>})</span><span style=color:#bfbab0cc>;
</span><span>                </span><span style=color:#f07178>contender</span><span>(lck)</span><span style=color:#bfbab0cc>;
</span><span>            })</span><span style=color:#bfbab0cc>;
</span><span>        }
</span><span>        s</span><span style=color:#f29668>.</span><span style=color:#f07178>spawn</span><span>(|| </span><span style=color:#f07178>timed_consumer</span><span>(</span><span style=color:#f29668>&</span><span>lock))</span><span style=color:#bfbab0cc>;
</span><span>        s</span><span style=color:#f29668>.</span><span style=color:#f07178>spawn</span><span>(|| </span><span style=color:#f07178>producer</span><span>(</span><span style=color:#f29668>&</span><span>lock))</span><span style=color:#bfbab0cc>;
</span><span>    })
</span><span>}
</span></code></pre><h3 id=starting-point><a aria-label="Anchor link for: starting-point" class=zola-anchor href=#starting-point>Starting Point</a></h3><p>We use the <code>Seqlock</code> code we implemented above as the initial point, leading to the following latency timings for a single consumer (left) and 5 consumers (right):<p><img alt src=https://louisponet.github.io/blog/posts/icc-1-seqlock/consumer_latency_initial.png#noborder title=initial_consumer_latency> <em>Fig 3. Initial Consumer Latency</em><p>Would you look at that: timings are very stable without much jitter (tuning works!), the latency increase with increasing <code>Consumer</code> count is extremely minimal while the <code>Producer</code> gets... even faster(?), somehow. I triple checked and it is consistently reproducible.<h3 id=optimization><a aria-label="Anchor link for: optimization" class=zola-anchor href=#optimization>Optimization</a></h3><p>We are, however, still quite far off the ~30-40ns latency target. Looking closer at the <code>write</code> function, we realize that <code>fetch_add</code> is a single instruction version of lines (1) and (2):<pre class=language-rust data-lang=rust data-linenos style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><table><tbody><tr><td><mark style=background-color:#0a0e12>1</mark><td><mark style=background-color:#0a0e12><span>    </span><span style=color:#f73>let</span><span> v </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>version</span><span style=color:#f29668>.</span><span style=color:#f07178>load</span><span>(Ordering</span><span style=color:#f29668>::</span><span>Relaxed)</span><span style=color:#f29668>.</span><span style=color:#f07178>wrapping_add</span><span>(</span><span style=color:#f29718>1</span><span>)</span><span style=color:#bfbab0cc>;
</span></mark><tr><td><mark style=background-color:#0a0e12>2</mark><td><mark style=background-color:#0a0e12><span>    </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>version</span><span style=color:#f29668>.</span><span style=color:#f07178>store</span><span>(v</span><span style=color:#bfbab0cc>, </span><span>Ordering</span><span style=color:#f29668>::</span><span>Release)</span><span style=color:#bfbab0cc>;
</span></mark><tr><td>3<td><span>    </span><span style=color:#f07178>compiler_fence</span><span>(Ordering</span><span style=color:#f29668>::</span><span>AcqRel)</span><span style=color:#bfbab0cc>;
</span><tr><td>4<td><span>    </span><span style=color:#f73>unsafe </span><span>{ </span><span style=color:#f29668>*</span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>data</span><span style=color:#f29668>.</span><span style=color:#f07178>get</span><span>() </span><span style=color:#f29668>= *</span><span>val }</span><span style=color:#bfbab0cc>;
</span><tr><td>5<td><span>    </span><span style=color:#f07178>compiler_fence</span><span>(Ordering</span><span style=color:#f29668>::</span><span>AcqRel)</span><span style=color:#bfbab0cc>;
</span><tr><td>6<td><span>    </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>version</span><span style=color:#f29668>.</span><span style=color:#f07178>store</span><span>(v</span><span style=color:#f29668>.</span><span style=color:#f07178>wrapping_add</span><span>(</span><span style=color:#f29718>1</span><span>)</span><span style=color:#bfbab0cc>, </span><span>Ordering</span><span style=color:#f29668>::</span><span>Release)</span><span style=color:#bfbab0cc>;
</span></table></code></pre><p>which we thus change to:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span>    </span><span style=color:#f73>let</span><span> v </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>version</span><span style=color:#f29668>.</span><span style=color:#f07178>fetch_add</span><span>(</span><span style=color:#f29718>1</span><span style=color:#bfbab0cc>, </span><span>Ordering</span><span style=color:#f29668>::</span><span>Release)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f07178>compiler_fence</span><span>(Ordering</span><span style=color:#f29668>::</span><span>AcqRel)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f73>unsafe </span><span>{ </span><span style=color:#f29668>*</span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>data</span><span style=color:#f29668>.</span><span style=color:#f07178>get</span><span>() </span><span style=color:#f29668>= *</span><span>val }</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f07178>compiler_fence</span><span>(Ordering</span><span style=color:#f29668>::</span><span>AcqRel)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>version</span><span style=color:#f29668>.</span><span style=color:#f07178>store</span><span>(v</span><span style=color:#f29668>.</span><span style=color:#f07178>wrapping_add</span><span>(</span><span style=color:#f29718>2</span><span>)</span><span style=color:#bfbab0cc>, </span><span>Ordering</span><span style=color:#f29668>::</span><span>Release)</span><span style=color:#bfbab0cc>;
</span></code></pre><p>Measuring again, we find that this leads to a serious improvement, almost halving the latency in the 1 <code>Consumer</code> case (left), while also slightly improving the 5 <code>Consumer</code> case (right):<p><img alt src=https://louisponet.github.io/blog/posts/icc-1-seqlock/consumer_latency_improved.png#noborder title=improved_consumer_latency> <em>Fig 4. Optimized Consumer Latency</em><p>Unfortunately, there is nothing that can be optimized on the <code>read</code> side of things.<p>One final optimization we'll proactively do is to add <code>#[repr(align(64))]</code> the <code>Seqlocks</code>:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>repr</span><span>(</span><span style=color:#ffb454>align</span><span>(64))]
</span><span style=color:#f73>pub struct </span><span style=color:#59c2ff>Seqlock</span><span>&LTT> {
</span><span>    version</span><span style=color:#bfbab0cc>:</span><span> AtomicUsize,
</span><span>    data</span><span style=color:#bfbab0cc>: </span><span>UnsafeCell&LTT>,
</span><span>}
</span></code></pre><p>This fixes potential <a href=https://en.wikipedia.org/wiki/False_sharing>false sharing</a> issues by never having two or more <code>Seqlocks</code> on a single cache line. While it is not very important when using a single <code>Seqlock</code>, it becomes crucial when using them inside <code>Queues</code> and <code>SeqlockVectors</code>.<p>Looking back at our original design goals:<ul><li>close to minimum inter core latency<li><code>Producers</code> are never blocked<li><code>Consumers</code> don't impact the <code>Producers</code> and themselves + adding more <code>Consumers</code> doesn't dramatically decrease performance</ul><p>our implementation seems to be as good as it can be!<p>We thus conclude our deep dive into <code>Seqlocks</code> here. It is the main building block for the <code>Queues</code> and <code>SeqlockVectors</code> we will discuss in Pt 2 on inter core communication.<p>See you then!<h1 id=possible-future-investigations-improvements><a aria-label="Anchor link for: possible-future-investigations-improvements" class=zola-anchor href=#possible-future-investigations-improvements>Possible future investigations/improvements</a></h1><ul><li>Use the <a href=https://www.felixcloutier.com/x86/cldemote><code>cldemote</code></a> to force the <code>Producer</code> to immediately flush the <code>Seqlock</code> data to the consumers<li><a href=https://stackoverflow.com/questions/74956482/working-example-of-umonitor-umwait-based-assembly-asm-spin-wait-loops-as-a-rep#>UMONITOR/UMWAIT spin-wait loop</a></ul></section></article></main><div class=giscus></div><script async crossorigin data-category=Announcements data-category-id=DIC_kwDOL2wVKc4Cfndy data-emit-metadata=0 data-input-position=top data-lang=en data-mapping=pathname data-reactions-enabled=1 data-repo=louisponet/blog data-repo-id=R_kgDOL2wVKQ data-strict=0 data-theme=dark src=https://giscus.app/client.js></script></div>