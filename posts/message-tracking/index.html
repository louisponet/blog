<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Automatic Message Tracking and Timing
        
    </title><meta content="Automatic Message Tracking and Timing" property=og:title><meta content="How Mantra automatically tracks and times each message." property=og:description><meta content="How Mantra automatically tracks and times each message." name=description><link href=/icon/favicon.svg rel=icon type=image/png><link href=https://louisponet.github.io/blog/fonts.css rel=stylesheet><script src=https://louisponet.github.io/blog/js/codeblock.js></script><script src=https://louisponet.github.io/blog/js/toc.js></script><script>MathJax={tex:{inlineMath:[[`\$`,`\$`],[`\\\\(`,`\\\\)`]]}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="Louis Ponet" href=https://louisponet.github.io/blog/atom.xml rel=alternate type=application/atom+xml><link href=https://louisponet.github.io/blog/theme/light.css rel=stylesheet><link href=https://louisponet.github.io/blog/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://louisponet.github.io/blog/js/themetoggle.js></script><script>setTheme(getSavedTheme())</script><link href=https://louisponet.github.io/blog/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://louisponet.github.io/blog>Louis Ponet</a><div class=socials><a class=social href=https://github.com/louisponet/ rel=me> <img alt=github src=https://louisponet.github.io/blog/social_icons/github.svg> </a><a class=social href=https://www.linkedin.com/in/louis-ponet-phd-384ba0b6/ rel=me> <img alt=linkedin src=https://louisponet.github.io/blog/social_icons/linkedin.svg> </a><a href="https://scholar.google.com/citations?hl=en&user=oAp2Siow_v8C" class=social rel=me> <img alt=scholar src=https://louisponet.github.io/blog/social_icons/scholar.svg> </a><a href="mailto:louisponet@gmail.com?subject=Howdy%20from%20your%20blog" class=social rel=me> <img alt=email src=https://louisponet.github.io/blog/social_icons/email.svg> </a></div></div><nav><a href=https://louisponet.github.io/blog/posts style=margin-left:.5em>/posts</a><a href=https://louisponet.github.io/blog/about style=margin-left:.5em>/about</a><a href=https://louisponet.github.io/blog/tags style=margin-left:.5em>/tags</a> |<a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://louisponet.github.io/blog/feather/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://louisponet.github.io/blog/feather/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>Automatic Message Tracking and Timing<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2025-01-01</time><span class=tags-label> :: Tags:</span><span class=tags> <a class=post-tag href=https://louisponet.github.io/blog/tags/mantra/>mantra</a>, <a class=post-tag href=https://louisponet.github.io/blog/tags/telemetry/>telemetry</a> </span></div></div><div class=toc-container><h1 class=toc-title>Table of Contents</h1><ul class=toc-list><li><a href=https://louisponet.github.io/blog/posts/message-tracking/#overview-context>Overview/Context</a><li><a href=https://louisponet.github.io/blog/posts/message-tracking/#trackingtimestamp-and-queuemessage>TrackingTimestamp and QueueMessage</a><li><a href=https://louisponet.github.io/blog/posts/message-tracking/#actor-spine-and-spineadapters>Actor, Spine and SpineAdapters</a><li><a href=https://louisponet.github.io/blog/posts/message-tracking/#message-tracking-and-persistence>Message Tracking and Persistence</a><li><a href=https://louisponet.github.io/blog/posts/message-tracking/#performance>Performance</a><li><a href=https://louisponet.github.io/blog/posts/message-tracking/#conclusion>Conclusion</a></ul></div><section class=body><p>Happy new year, all!<p>In this quick post we will take a slight deviation away from the low level details of implementing a message passing distributed system. Instead, we focus on a concrete application that the low-latency message <code>Queues</code> we implemented <a href=https://louisponet.github.io/blog/posts/icc-2-queues-vectors/>in the previous post</a> allow for.<h1 id=overview-context><a aria-label="Anchor link for: overview-context" class=zola-anchor href=#overview-context>Overview/Context</a></h1><p>As I have mentioned before, one of the main points of the <code>Queues</code> is that <code>Consumers</code> have absolutely no impact on <code>Producers</code> and other <code>Consumers</code>. That means that we can attach auxilliary systems without impacting the main system's functionaly if we wanted to observe how it is behaving. This is particularly useful for gathering telemetry, provided that the messages that are going through the system are slightly augmented with some additional metadata. While the main system will therefore have to perform a bit more work, the real-world performance metrics and debugging capabilities that result from it are well worth the cost. In fact, after having implemented the design below, I found that the overhead was so minimal that I forewent the planned feature flag disabling of the tracking.<p>Moving on, the main telemetry metrics I was interested in are:<ul><li>message propagation latency: how long does it take for downstream messages to arrive at different parts of the system based on an ingested message<li>message processing time: how long does it take for message of type <code>T</code> to be processed by system <code>X</code><li>what are the downstream message produced by a given ingested message</ul><p>This post will detail the message tracking design in <strong>Mantra</strong> to handle all of this as seemlessly as possible.<h1 id=trackingtimestamp-and-queuemessage><a aria-label="Anchor link for: trackingtimestamp-and-queuemessage" class=zola-anchor href=#trackingtimestamp-and-queuemessage><code>TrackingTimestamp</code> and <code>QueueMessage</code></a></h1><p>As mentioned before, we need to slightly "dress" raw data messages in order to track them and produce the desired telementry. Remembering the lessons learned in previous posts, our main tool will again be the <code>rdtscp</code> cpu cycle counter. This does mean that we only care about on the <strong>same machine</strong> message tracking. If messages need to be tracked across machines, there is no way around using an actual timestamp (and potentially some sort of global UUID between machines).<p>The piece of metadata that is attached to the raw data messages is a <code>TrackingTimestamp</code>:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>derive</span><span>(Debug</span><span style=color:#bfbab0cc>,</span><span> Copy</span><span style=color:#bfbab0cc>,</span><span> Clone</span><span style=color:#bfbab0cc>,</span><span> PartialEq</span><span style=color:#bfbab0cc>,</span><span> Serialize</span><span style=color:#bfbab0cc>,</span><span> Default</span><span style=color:#bfbab0cc>,</span><span> Deserialize)]
</span><span style=color:#f73>pub struct </span><span style=color:#59c2ff>TrackingTimestamp </span><span>{
</span><span>    </span><span style=color:#f73>pub </span><span>origin_t</span><span style=color:#bfbab0cc>:</span><span>  OriginTime,  </span><span style=color:#5c6773;font-style:italic>//basically the rdtscp count when the initial message was ingested by the system
</span><span>    </span><span style=color:#f73>pub </span><span>publish_t</span><span style=color:#bfbab0cc>:</span><span> PublishTime, </span><span style=color:#5c6773;font-style:italic>//when was this message published to a Queue
</span><span>}
</span></code></pre><p>The <code>publish_t</code> allows to track how long a message was pending in a <code>Queue</code> before it was picked up by the <code>Consumer</code>, and to easily reconstruct a timeline after a run of the system.<p>All messages going through the system will thus be <code>QueueMessages</code>:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>derive</span><span>(Default</span><span style=color:#bfbab0cc>,</span><span> Debug</span><span style=color:#bfbab0cc>,</span><span> Clone</span><span style=color:#bfbab0cc>,</span><span> Copy</span><span style=color:#bfbab0cc>,</span><span> Serialize</span><span style=color:#bfbab0cc>,</span><span> Deserialize)]
</span><span style=color:#f73>pub struct </span><span style=color:#59c2ff>QueueMessage</span><span>&LTT> {
</span><span>    </span><span style=color:#f73>pub </span><span>timestamp</span><span style=color:#bfbab0cc>:</span><span> TrackingTimestamp,
</span><span>    </span><span style=color:#f73>pub </span><span>data</span><span style=color:#bfbab0cc>:</span><span>      T,
</span><span>}
</span></code></pre><h1 id=actor-spine-and-spineadapters><a aria-label="Anchor link for: actor-spine-and-spineadapters" class=zola-anchor href=#actor-spine-and-spineadapters><code>Actor</code>, <code>Spine</code> and <code>SpineAdapters</code></a></h1><p>Now, it becomes extremely tedious and ugly if each of the <code>Producers</code> and <code>Consumers</code> have to take care of unpacking the <code>data</code>, process it, and then produce a new <code>QueueMessage</code> with the correct <code>origin_t</code> and <code>publish_t</code>, while also publishing the timing telemetry to the right timing queues. Instead, I designed <strong>Mantra</strong> in such a way that all of this is handled behind the scenes, and sub-systems can just take care of their business logic.<p>We start by defining an <code>Actor</code> trait which is implemented by each sub-system. An <code>Actor</code> has a <code>name</code> which is used to create timing queues, a <code>loop_body</code> implementing the business logic, and potentially the <code>on_init</code> and <code>on_exit</code> functions which are called before the main <code>Actor</code> loop starts and after it finishes, respectively.<p>The second piece of the puzzle is the <code>Spine</code> which, as the name suggests, forms the backbone of the entire system, grouping all the different message queues:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#f73>pub struct </span><span style=color:#59c2ff>Spine </span><span>{
</span><span>    </span><span style=color:#f73>pub </span><span>msgs1</span><span style=color:#bfbab0cc>: </span><span>Queue&LTQueueMessage&LTMsgType1>>,
</span><span>    </span><span style=color:#f73>pub </span><span>msgs2</span><span style=color:#bfbab0cc>: </span><span>Queue&LTQueueMessage&LTMsgType2>>,
</span><span>}
</span></code></pre><p>Each of the <code>Actors</code> is then given a <code>SpineAdapter</code> to <code>produce</code> and <code>consume</code> messages with:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>derive</span><span>(Clone</span><span style=color:#bfbab0cc>,</span><span> Copy</span><span style=color:#bfbab0cc>,</span><span> Debug)]
</span><span style=color:#f73>pub struct </span><span style=color:#59c2ff>SpineAdapter </span><span>{
</span><span>    </span><span style=color:#f73>pub </span><span>consumers</span><span style=color:#bfbab0cc>:</span><span> SpineConsumers,
</span><span>    </span><span style=color:#f73>pub </span><span>producers</span><span style=color:#bfbab0cc>:</span><span> SpineProducers,
</span><span>}
</span><span>
</span><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>derive</span><span>(Clone</span><span style=color:#bfbab0cc>,</span><span> Copy</span><span style=color:#bfbab0cc>,</span><span> Debug)]
</span><span style=color:#f73>pub struct </span><span style=color:#59c2ff>SpineProducers </span><span>{
</span><span>    </span><span style=color:#f73>pub </span><span>msgs1</span><span style=color:#bfbab0cc>:     </span><span>Producer&LTQueueMessage&LTMsgType1>>,
</span><span>    </span><span style=color:#f73>pub </span><span>msgs2</span><span style=color:#bfbab0cc>:     </span><span>Producer&LTQueueMessage&LTMsgType2>>,
</span><span>    </span><span style=color:#f73>pub </span><span>timestamp</span><span style=color:#bfbab0cc>:</span><span> TrackingTimestamp,
</span><span>}
</span><span>
</span><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>derive</span><span>(Clone</span><span style=color:#bfbab0cc>,</span><span> Copy</span><span style=color:#bfbab0cc>,</span><span> Debug)]
</span><span style=color:#f73>pub struct </span><span style=color:#59c2ff>SpineConsumers </span><span>{
</span><span>    </span><span style=color:#f73>pub </span><span>msgs1</span><span style=color:#bfbab0cc>: </span><span>Consumer&LTQueueMessage&LTMsgType1>>,
</span><span>    </span><span style=color:#f73>pub </span><span>msgs2</span><span style=color:#bfbab0cc>: </span><span>Consumer&LTQueueMessage&LTMsgType2>>,
</span><span>}
</span></code></pre><p>This looks a bit convoluted, but it is this combined <code>SpineAdapter</code> structure that enables the core functionality: when the <code>SpineConsumers</code> consume a message, the <code>timestamp</code> of that message is set on the <code>SpineProducers</code>, which is then attached to whatever message that the <code>Actor</code> produces based on the consumed one. It completely solves the first issue of manually having to unpack and repack each message.<p>The second part is the automatic latency and processing time tracking of the messages. To enable this, we define a slightly augmented <code>Consumer</code> that holds a <a href=https://louisponet.github.io/blog/posts/icc-1-seqlock/#timing-101><code>Timer</code></a>:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>derive</span><span>(Clone</span><span style=color:#bfbab0cc>,</span><span> Copy</span><span style=color:#bfbab0cc>,</span><span> Debug)]
</span><span style=color:#f73>pub struct </span><span style=color:#59c2ff>Consumer</span><span>&LTT</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>'static </span><span style=color:#f29668>+ </span><span style=color:#39bae6;font-style:italic>Copy </span><span style=color:#f29668>+ </span><span style=color:#39bae6;font-style:italic>Default</span><span>> {
</span><span>    timer</span><span style=color:#bfbab0cc>:</span><span>    Timer,
</span><span>    consumer</span><span style=color:#bfbab0cc>: </span><span>ma_communication</span><span style=color:#f29668>::</span><span>Consumer&LTQueueMessage&LTT>>,
</span><span>}
</span></code></pre><p>These structs hold all the information to enable the api we want to end up with in the sub systems:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#f73>fn </span><span style=color:#ffb454>loop_body</span><span>(</span><span style=color:#f29668>&</span><span style=color:#f73>mut </span><span style=color:#f29718>self</span><span>, </span><span style=color:#f29718>adapter</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span style=color:#f73>mut</span><span> SpineAdapter) {
</span><span>
</span><span>    adapter</span><span style=color:#f29668>.</span><span style=color:#f07178>consume</span><span>(|</span><span style=color:#f29718>msg</span><span style=color:#bfbab0cc>:</span><span> MsgType1</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>producers</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>SpineProducers|{
</span><span>        </span><span style=color:#5c6773;font-style:italic>// handle msg type 1
</span><span>    })</span><span style=color:#bfbab0cc>;
</span><span>    adapter</span><span style=color:#f29668>.</span><span style=color:#f07178>consume</span><span>(|</span><span style=color:#f29718>msg</span><span style=color:#bfbab0cc>:</span><span> MsgType2</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>producers</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>SpineProducers|{
</span><span>        </span><span style=color:#5c6773;font-style:italic>// handle msg type 2
</span><span>    })</span><span style=color:#bfbab0cc>;
</span><span>}
</span></code></pre><p>with the latencies and processing times automatically tracked in timing queues.<p>The additional implementation needed looks like (some further implementation details are left to the reader):<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#5c6773;font-style:italic>// Initialization
</span><span style=color:#f73>impl </span><span style=color:#59c2ff>SpineAdapter </span><span>{
</span><span>    </span><span style=color:#f73>pub fn </span><span style=color:#ffb454>attach</span><span>&LTAC</span><span style=color:#bfbab0cc>:</span><span> Actor>(</span><span style=color:#f29718>actor</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>AC, </span><span style=color:#f29718>spine</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>Spine) </span><span style=color:#bfbab0cc>-> </span><span style=color:#f73>Self </span><span>{
</span><span>        </span><span style=color:#f73>Self </span><span>{
</span><span>            consumers</span><span style=color:#bfbab0cc>: </span><span>SpineConsumers</span><span style=color:#f29668>::</span><span>attach(actor</span><span style=color:#bfbab0cc>,</span><span> spine)</span><span style=color:#bfbab0cc>,
</span><span>            producers</span><span style=color:#bfbab0cc>: </span><span>SpineProducers</span><span style=color:#f29668>::</span><span>attach(actor</span><span style=color:#bfbab0cc>,</span><span> spine)</span><span style=color:#bfbab0cc>,
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#f73>impl </span><span style=color:#59c2ff>SpineProducers </span><span>{
</span><span>    </span><span style=color:#f73>pub fn </span><span style=color:#ffb454>attach</span><span>(</span><span style=color:#f29718>spine</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>Spine) </span><span style=color:#bfbab0cc>-> </span><span style=color:#f73>Self </span><span>{
</span><span>        </span><span style=color:#f73>Self </span><span>{
</span><span>            msgs1</span><span style=color:#bfbab0cc>: </span><span>Producer</span><span style=color:#f29668>::</span><span>from(spine)</span><span style=color:#bfbab0cc>,
</span><span>            msgs2</span><span style=color:#bfbab0cc>: </span><span>Producer</span><span style=color:#f29668>::</span><span>from(spine)</span><span style=color:#bfbab0cc>,
</span><span>            timestamp</span><span style=color:#bfbab0cc>: </span><span>TrackingTimestamp</span><span style=color:#f29668>::</span><span>default()</span><span style=color:#bfbab0cc>,
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#f73>impl </span><span style=color:#59c2ff>SpineConsumers </span><span>{
</span><span>    </span><span style=color:#f73>pub fn </span><span style=color:#ffb454>attach</span><span>&LTAC</span><span style=color:#bfbab0cc>:</span><span> Actor>(</span><span style=color:#f29718>actor</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>AC, </span><span style=color:#f29718>spine</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>Spine) </span><span style=color:#bfbab0cc>-> </span><span style=color:#f73>Self </span><span>{
</span><span>        </span><span style=color:#f73>Self </span><span>{
</span><span>            msgs1</span><span style=color:#bfbab0cc>: </span><span>Consumer</span><span style=color:#f29668>::</span><span>attach(actor</span><span style=color:#bfbab0cc>,</span><span> spine)</span><span style=color:#bfbab0cc>,
</span><span>            msgs2</span><span style=color:#bfbab0cc>: </span><span>Consumer</span><span style=color:#f29668>::</span><span>attach(actor</span><span style=color:#bfbab0cc>,</span><span> spine)</span><span style=color:#bfbab0cc>,
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#f73>impl</span><span>&LTT</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>'static </span><span style=color:#f29668>+ </span><span style=color:#39bae6;font-style:italic>Copy </span><span style=color:#f29668>+ </span><span style=color:#39bae6;font-style:italic>Default</span><span>> </span><span style=color:#59c2ff>Consumer</span><span>&LTT> {
</span><span>    </span><span style=color:#f73>pub fn </span><span style=color:#ffb454>attach</span><span>&LTA</span><span style=color:#bfbab0cc>:</span><span> Actor>(</span><span style=color:#f29718>actor</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>A, </span><span style=color:#f29718>spine</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>Spine) </span><span style=color:#bfbab0cc>-> </span><span style=color:#f73>Self
</span><span>    </span><span style=color:#f73>where
</span><span>        Queue&LTT></span><span style=color:#bfbab0cc>: </span><span style=color:#f73>for</span><span><</span><span style=color:#f73>'a</span><span>> </span><span style=color:#39bae6;font-style:italic>From</span><span><</span><span style=color:#f29668>&</span><span style=color:#f73>'a</span><span> Spine>,
</span><span>    {
</span><span>        </span><span style=color:#f73>let</span><span> timer </span><span style=color:#f29668>= </span><span>Timer</span><span style=color:#f29668>::</span><span>new(</span><span style=color:#f07178>format!</span><span>(
</span><span>            </span><span style=color:#c2d94c>"</span><span style=color:#f29718>{}</span><span style=color:#c2d94c>-</span><span style=color:#f29718>{}</span><span style=color:#c2d94c>"</span><span style=color:#bfbab0cc>,
</span><span>            actor</span><span style=color:#f29668>.</span><span style=color:#f07178>name</span><span>()</span><span style=color:#bfbab0cc>,
</span><span>            </span><span style=color:#f73>crate</span><span style=color:#f29668>::</span><span>utils</span><span style=color:#f29668>::</span><span>last_part(std</span><span style=color:#f29668>::</span><span>any</span><span style=color:#f29668>::</span><span>type_name</span><span style=color:#f29668>::</span><span>&LTT>())
</span><span>        ))</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#f73>let</span><span> q</span><span style=color:#bfbab0cc>: </span><span>Queue&LTT> </span><span style=color:#f29668>=</span><span> spine</span><span style=color:#f29668>.</span><span style=color:#f07178>into</span><span>()</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#f73>Self </span><span>{
</span><span>            timer</span><span style=color:#bfbab0cc>,
</span><span>            consumer</span><span style=color:#bfbab0cc>: </span><span>ma_communication</span><span style=color:#f29668>::</span><span>Consumer</span><span style=color:#f29668>::</span><span>from(q)</span><span style=color:#bfbab0cc>,
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#5c6773;font-style:italic>// Consuming
</span><span style=color:#f73>impl </span><span style=color:#59c2ff>SpineAdapter </span><span>{
</span><span>    </span><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>inline</span><span>]
</span><span>    </span><span style=color:#f73>pub fn </span><span style=color:#ffb454>consume</span><span>&LTT</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>'static </span><span style=color:#f29668>+ </span><span style=color:#39bae6;font-style:italic>Copy </span><span style=color:#f29668>+ </span><span style=color:#39bae6;font-style:italic>Default</span><span>, F>(</span><span style=color:#f29668>&</span><span style=color:#f73>mut </span><span style=color:#f29718>self</span><span>, </span><span style=color:#f73>mut </span><span style=color:#f29718>f</span><span style=color:#bfbab0cc>:</span><span> F)
</span><span>    </span><span style=color:#f73>where
</span><span>        SpineConsumers</span><span style=color:#bfbab0cc>: </span><span style=color:#39bae6;font-style:italic>AsMut</span><span>&LTConsumer&LTT>>,
</span><span>        F</span><span style=color:#bfbab0cc>:</span><span> FnMut(T, </span><span style=color:#f29668>&</span><span>SpineProducers),
</span><span>    {
</span><span>        </span><span style=color:#f73>let</span><span> consumer </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>consumers</span><span style=color:#f29668>.</span><span style=color:#f07178>as_mut</span><span>()</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#5c6773;font-style:italic>// Choice here is to always consume all messages of a given queue, could be changed to be only a single message
</span><span>        </span><span style=color:#f73>while</span><span> consumer</span><span style=color:#f29668>.</span><span style=color:#f07178>consume</span><span>(</span><span style=color:#f29668>&</span><span style=color:#f73>mut </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>producers</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668>&</span><span style=color:#f73>mut</span><span> f) {}
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#f73>impl</span><span>&LTT</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>'static </span><span style=color:#f29668>+ </span><span style=color:#39bae6;font-style:italic>Copy </span><span style=color:#f29668>+ </span><span style=color:#39bae6;font-style:italic>Default</span><span>> </span><span style=color:#59c2ff>Consumer</span><span>&LTT> {
</span><span>    </span><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>inline</span><span>]
</span><span>    </span><span style=color:#f73>pub fn </span><span style=color:#ffb454>consume</span><span>&LTF>(</span><span style=color:#f29668>&</span><span style=color:#f73>mut </span><span style=color:#f29718>self</span><span>, </span><span style=color:#f29718>producers</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span style=color:#f73>mut</span><span> SpineProducers, </span><span style=color:#f73>mut </span><span style=color:#f29718>f</span><span style=color:#bfbab0cc>:</span><span> F) </span><span style=color:#bfbab0cc>-> </span><span style=color:#f73>bool
</span><span>    </span><span style=color:#f73>where
</span><span>        F</span><span style=color:#bfbab0cc>:</span><span> FnMut(T, </span><span style=color:#f29668>&</span><span>SpineProducers),
</span><span>    {
</span><span>        </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>consumer</span><span style=color:#f29668>.</span><span style=color:#f07178>consume</span><span>(|</span><span style=color:#f29668>&</span><span style=color:#f73>mut </span><span style=color:#f29718>m</span><span>| {
</span><span>            producers</span><span style=color:#f29668>.</span><span>timestamp </span><span style=color:#f29668>=</span><span> m</span><span style=color:#f29668>.</span><span>timestamp</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>timer</span><span style=color:#f29668>.</span><span style=color:#f07178>start</span><span>()</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=color:#f07178>f</span><span>(m</span><span style=color:#f29668>.</span><span>data</span><span style=color:#bfbab0cc>,</span><span> producers)</span><span style=color:#bfbab0cc>;
</span><span>            </span><span style=color:#5c6773;font-style:italic>// Report processing time and latency after having processed message.
</span><span>            </span><span style=color:#5c6773;font-style:italic>// This minimizes the impact of telemetry on latency
</span><span>            </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>timer</span><span style=color:#f29668>.</span><span style=color:#f07178>stop_and_latency</span><span>(m</span><span style=color:#f29668>.</span><span>timestamp</span><span style=color:#f29668>.</span><span style=color:#f07178>origin_t</span><span>()</span><span style=color:#f29668>.</span><span style=color:#f07178>into</span><span>())
</span><span>        })
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#5c6773;font-style:italic>// Producing
</span><span style=color:#f73>impl </span><span style=color:#59c2ff>SpineProducers </span><span>{
</span><span>    </span><span style=color:#f73>pub fn </span><span style=color:#ffb454>produce</span><span>&LTT</span><span style=color:#bfbab0cc>: </span><span style=color:#39bae6;font-style:italic>Copy</span><span>>(</span><span style=color:#f29668>&</span><span style=color:#f29718>self</span><span>, </span><span style=color:#f29718>d</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>T)
</span><span>    </span><span style=color:#f73>where
</span><span>        </span><span style=color:#f73>Self</span><span style=color:#bfbab0cc>: </span><span style=color:#39bae6;font-style:italic>AsRef</span><span>&LTProducer&LTT>>,
</span><span>    {
</span><span>        </span><span style=color:#f73>let</span><span> msg </span><span style=color:#f29668>=</span><span> QueueMessage {
</span><span>            timestamp</span><span style=color:#bfbab0cc>: </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>timestamp</span><span style=color:#f29668>.</span><span style=color:#f07178>set_publish_t</span><span>()</span><span style=color:#bfbab0cc>,
</span><span>            data</span><span style=color:#bfbab0cc>:      </span><span style=color:#f29668>*</span><span>d</span><span style=color:#bfbab0cc>,
</span><span>        }</span><span style=color:#bfbab0cc>;
</span><span>        </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span style=color:#f07178>as_ref</span><span>()</span><span style=color:#f29668>.</span><span style=color:#f07178>produce</span><span>(</span><span style=color:#f29668>&</span><span>msg)</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#f73>impl </span><span style=color:#59c2ff>SpineAdapter </span><span>{
</span><span>    </span><span style=color:#f73>pub fn </span><span style=color:#ffb454>produce</span><span>&LTT</span><span style=color:#bfbab0cc>: </span><span style=color:#39bae6;font-style:italic>Copy</span><span>>(</span><span style=color:#f29668>&</span><span style=color:#f73>mut </span><span style=color:#f29718>self</span><span>, </span><span style=color:#f29718>d</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>T)
</span><span>    </span><span style=color:#f73>where
</span><span>        SpineProducers</span><span style=color:#bfbab0cc>: </span><span style=color:#39bae6;font-style:italic>AsRef</span><span>&LTProducer&LTT>>,
</span><span>    {
</span><span>        </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>producers</span><span style=color:#f29668>.</span><span style=color:#f07178>produce</span><span>(d)</span><span style=color:#bfbab0cc>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#f73>pub fn </span><span style=color:#ffb454>set_origin_t</span><span>(</span><span style=color:#f29668>&</span><span style=color:#f73>mut </span><span style=color:#f29718>self</span><span>, </span><span style=color:#f29718>origin_t</span><span style=color:#bfbab0cc>:</span><span> OriginTime) {
</span><span>        </span><span style=color:#39bae6;font-style:italic>self</span><span style=color:#f29668>.</span><span>producers</span><span style=color:#f29668>.</span><span>timestamp</span><span style=color:#f29668>.</span><span style=color:#f73>origin_t </span><span style=color:#f29668>= </span><span style=color:#f73>origin_t
</span><span>    }
</span><span>
</span><span>}
</span></code></pre><h1 id=message-tracking-and-persistence><a aria-label="Anchor link for: message-tracking-and-persistence" class=zola-anchor href=#message-tracking-and-persistence>Message Tracking and Persistence</a></h1><p>Another sideffect of our implementation of <code>TrackingTimestamp</code> with <code>OriginTime</code> based on <code>rdtscp</code> and the fact that it is automatically attached to downstream messages is that it effectively allows to create a "message tree". After all, <code>rdtscp</code> can be used as a poor man's unique identifier, tying parent and offspring messages together.<p>Furthermore, since we now have all <code>Queues</code> grouped in a single <code>Spine</code>, it is very trivial to attach an <code>Actor</code> that takes care of persisting each and every message that flows through the system. Given that we have the <code>OriginTime</code> and <code>PublishTime</code> of each message, we can reconstruct a timeline of the entire system's running. If we also store the produced timing messages, we get even more information on the system's performance: using the <code>consume</code> timestamp with <code>PublishTime</code> would allow to measure exactly the processing time of <code>MsgTypeX</code> -> <code>MsgTypeY</code>, and how long a message sat inside a <code>Queue</code> before it was handled. Finally, with a minimal amount of elbow grease, it is possible to use the top 16 bits of <code>PublishTime</code> to store a u16 <code>ActorId</code> in case multiple <code>Actors</code> produce to the same message type, to be able to disentangle the performance of each <code>Actor</code> separately.<h1 id=performance><a aria-label="Anchor link for: performance" class=zola-anchor href=#performance>Performance</a></h1><p>While I will forego benchmarking the overhead of this type of telemetry gathering, I can posit that it is very minimal. The main differences to an unobservable system are:<ul><li>each message is 16 bytes larger<li>on ingestion we take a <code>rdtscp</code> timestamp with 6-9ns overhead<li>1 <code>rdtscp</code> before handling a consumed message<li>1 <code>rdtscp</code> when producing a message<li>1 <code>rdtscp</code> after handling a message, followed by producing a TimingMessage ~(6-9 + ~12)ns</ul><h1 id=conclusion><a aria-label="Anchor link for: conclusion" class=zola-anchor href=#conclusion>Conclusion</a></h1><p>With this relatively simple implementation and a very minimal performance sacrifice we gain an incredible wealth of information and observability of the system. Having this design as the fundamental backbone of <strong>Mantra</strong> has proven invaluable in developing more advanced functionality as it allows for effortless performance tracking of new or updated parts, as well as very effective debugging.<p>This concludes this post. A tad lighter than previous ones but hopefully just as informative and intersting. See you next time!</section></article></main><div class=giscus></div><script async crossorigin data-category=Announcements data-category-id=DIC_kwDOL2wVKc4Cfndy data-emit-metadata=0 data-input-position=top data-lang=en data-mapping=pathname data-reactions-enabled=1 data-repo=louisponet/blog data-repo-id=R_kgDOL2wVKQ data-strict=0 data-theme=dark src=https://giscus.app/client.js></script></div>